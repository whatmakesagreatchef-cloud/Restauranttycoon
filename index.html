<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Restaurant Tycoon — Flat Pack (Build Mode / Layout)</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#171a21; --panel2:#11131a; --text:#e8e8ea; --muted:#a6a6ad;
      --accent:#7bdcff; --good:#7CFF8A; --bad:#ff6b6b; --warn:#ffd166;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    .wrap{ display:flex; min-height:100vh; gap:10px; padding:10px; }
    .left{ flex:1 1 auto; min-width:0; }
    .right{ width:470px; max-width:54vw; display:flex; flex-direction:column; gap:10px; }
    .card{ background:linear-gradient(180deg,var(--panel),#121522); border:1px solid #262b40; border-radius:12px; overflow:hidden; }
    .card h2{ margin:0; padding:10px 12px; font-size:13px; letter-spacing:.2px; color:#dfe6ff; background:linear-gradient(180deg,#1d2233,#141828); border-bottom:1px solid #262b40; display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .card .body{ padding:10px 12px; }
    canvas{ width:100%; height:calc(100vh - 20px); border-radius:12px; background:radial-gradient(1200px 700px at 30% 20%, #141a2a 0%, #0b0d14 40%, #070810 100%); border:1px solid #262b40; touch-action:none; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button{ background:#1c2336; color:var(--text); border:1px solid #2b3350; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover{ border-color:#3a4780; }
    button.primary{ background:linear-gradient(180deg,#243152,#1a2340); border-color:#4253a3; }
    button.danger{ background:linear-gradient(180deg,#3a1f23,#2a1719); border-color:#7a2d33; }
    button.mini{ padding:6px 8px; border-radius:8px; font-size:12px; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#0f1426; border:1px solid #2b3350; color:#dfe6ff; font-size:12px; }
    .small{ color:var(--muted); font-size:12px; }
    .hr{ height:1px; background:#262b40; margin:10px 0; }
    .kpi{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .kpi .box{ background:var(--panel2); border:1px solid #262b40; border-radius:12px; padding:8px; }
    .kpi .box .label{ color:var(--muted); font-size:12px; }
    .kpi .box .value{ font-size:16px; margin-top:2px; }

    .list{ max-height:205px; overflow:auto; padding-right:6px; }
    .staffList{ max-height:200px; overflow:auto; padding-right:6px; }
    .staff{ border:1px solid #262b40; background:#0f1426; border-radius:12px; padding:8px; margin-bottom:8px; }
    .staffTop{ display:flex; justify-content:space-between; gap:10px; align-items:flex-start; }
    select{ padding:7px 8px; border-radius:10px; border:1px solid #2b3350; background:#0b0f1f; color:#dfe6ff; }
    input[type="number"]{ width:92px; padding:7px 8px; border-radius:10px; border:1px solid #2b3350; background:#0b0f1f; color:#dfe6ff; }

    .ticketBox{ max-height:155px; overflow:auto; padding-right:6px; }
    .ticket{ border:1px solid #262b40; background:#0f1426; border-radius:12px; padding:8px; margin-bottom:8px; }
    .ticket .top{ display:flex; justify-content:space-between; gap:8px; }
    .bar{ height:8px; border-radius:999px; background:#0b0f1f; border:1px solid #262b40; overflow:hidden; margin-top:6px; }
    .bar > div{ height:100%; width:50%; background:linear-gradient(90deg,#7bdcff,#7cffc8); }

    .buildTools{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .toolBtn.active{ border-color:#7bdcff; box-shadow:0 0 0 2px rgba(123,220,255,0.12) inset; }
    .prop{ border:1px solid #262b40; background:#0f1426; border-radius:12px; padding:8px; margin-top:10px; }
    .prop b{ font-size:12px; }

    .toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:14px; background:#0f1426; border:1px solid #2b3350; border-radius:999px; padding:8px 12px; color:#dfe6ff; font-size:12px; opacity:0; transition:opacity .2s; pointer-events:none;}
    .toast.show{ opacity:1; }

    @media (max-width: 900px){
      .wrap{ flex-direction:column; }
      .right{ width:auto; max-width:none; }
      canvas{ height:52vh; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <canvas id="c" width="1200" height="760" aria-label="Restaurant map"></canvas>
  </div>

  <div class="right">
    <div class="card">
      <h2>
        <span>Restaurant Tycoon — Flat Pack</span>
        <span class="pill" id="modePill">Build</span>
      </h2>
      <div class="body">
        <div class="row" style="justify-content:space-between;">
          <div class="pill">Day <span id="dayPill">1</span></div>
          <div class="pill">Speed <span id="speedText">1×</span></div>
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="primary" id="btnBuildToggle">Enter Build</button>
          <button class="primary" id="btnStart" disabled>Start Service</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnSpeed">Speed Up</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>

        <div class="hr"></div>
        <div class="kpi">
          <div class="box"><div class="label">Cash</div><div class="value" id="cash">$0</div></div>
          <div class="box"><div class="label">Rating</div><div class="value" id="rating">0.0★</div></div>
          <div class="box"><div class="label">Profit Today</div><div class="value" id="profitToday">$0</div></div>
          <div class="box"><div class="label">Shift Left</div><div class="value" id="shiftTime">02:50</div></div>
        </div>

        <div class="hr"></div>
        <div class="row">
          <button id="btnHireCook">Hire Cook (+$120/day)</button>
          <button id="btnHireJanitor">Hire Janitor (+$90/day)</button>
          <button id="btnAutoAssign">Auto Assign Stations</button>
        </div>
        <div class="small" style="margin-top:8px;">
          New Stage 5: <b>Build Mode</b> — place tables & stations, and expand your floor plan.
        </div>
      </div>
    </div>

    <div class="card" id="buildCard">
      <h2>
        <span>Build Mode · Layout</span>
        <span class="pill" id="buildPill">Editing</span>
      </h2>
      <div class="body">
        <div class="small">Pick a tool, then tap/click the floor. Drag items to reposition.</div>

        <div class="hr"></div>
        <div class="buildTools">
          <button class="toolBtn active" data-tool="select">Select / Move</button>
          <button class="toolBtn" data-tool="table">Add Table ($250)</button>
          <button class="toolBtn" data-tool="prep">Add PREP Bench ($400)</button>
          <button class="toolBtn" data-tool="cook">Add COOK Line ($600)</button>
          <button class="toolBtn" data-tool="pass">Add PASS ($350)</button>
        </div>

        <div class="hr"></div>
        <div class="row">
          <button id="btnExpandFloor">Expand Floor +80w</button>
          <button id="btnExpandKitchen">Expand Kitchen +60h</button>
          <button class="danger" id="btnDelete" disabled>Delete Selected</button>
        </div>
        <div class="small" id="expandHint" style="margin-top:8px;">Expansion costs scale up each time.</div>

        <div class="prop" id="propBox" style="display:none;">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
            <div>
              <b id="propTitle">Selected</b>
              <div class="small" id="propSub">—</div>
            </div>
            <span class="pill" id="propPill">—</span>
          </div>

          <div class="row" id="tableProps" style="margin-top:8px; display:none;">
            <span class="small">Seats</span>
            <button class="mini" id="btnSeatsMinus">−</button>
            <input type="number" id="inpSeats" min="1" max="6" step="1" value="2" />
            <button class="mini" id="btnSeatsPlus">+</button>
          </div>

          <div class="row" id="stationProps" style="margin-top:8px; display:none;">
            <span class="small">Station type</span>
            <span class="pill" id="stationTypePill">—</span>
          </div>

          <div class="small" style="margin-top:8px;">
            Tip: More physical stations increase <b>max capacity</b> (up to staffing).
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2><span>Staff · Stations</span><span class="pill" id="staffPill">—</span></h2>
      <div class="body">
        <div class="small">Assign cooks to PREP / COOK / PASS / FLOAT. Station coverage affects speed and mistakes.</div>
        <div class="staffList" id="staffList"></div>
      </div>
    </div>

    <div class="card">
      <h2><span>Live Tickets</span><span class="pill" id="ticketCount">0</span></h2>
      <div class="body">
        <div class="row" style="justify-content:space-between; margin-bottom:8px;">
          <span class="small">86 Board: <b id="board86">None</b></span>
          <span class="pill" id="physPill">Tables 0 · Stations 0</span>
        </div>
        <div class="ticketBox" id="tickets"></div>
        <div class="small">Build mode is disabled during service.</div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ============================================================
   Restaurant Tycoon — Single-File Flat Pack
   Stage 5: Build Mode / Layout Editing (tables + stations + expansions)
   - drag & drop
   - physical stations cap throughput (up to staff capacity)
   ============================================================ */

/* -------------------- Util -------------------- */
const U = {
  clamp:(v,a,b)=>Math.max(a,Math.min(b,v)),
  lerp:(a,b,t)=>a+(b-a)*t,
  fmtMoney:(n)=>"$"+Math.round(n).toLocaleString(),
  now:()=>performance.now()/1000,
  rand:(a,b)=>a+Math.random()*(b-a),
  pick:(arr)=>arr[(Math.random()*arr.length)|0],
  uid:()=>Math.random().toString(36).slice(2,9),
  star:(r)=> (Math.round(r*10)/10).toFixed(1)+"★"
};
function toast(msg){
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>el.classList.remove("show"), 1500);
}
function pct(n){ return Math.round(U.clamp(n,0,1)*100); }

/* -------------------- Data -------------------- */
const DATA = {
  shiftSeconds: 170,
  spawnBase: 0.22,
  spawnMin: 0.08,
  spawnMax: 0.55,
  cleanlinessDecay: 0.0028,
  litterChance: 0.025,
  ratingFloor: 1.5,
  ratingCeil: 5.0,
  stations: ["PREP","COOK","PASS"],
  spoilRate: 0.22,

  // Costs
  costTable: 250,
  costPrep: 400,
  costCook: 600,
  costPass: 350,

  // Expansion scaling
  expandFloorBase: 1200,
  expandKitchenBase: 900,
  expandMult: 1.35,

  // Staff systems
  fatigueGainPerSec: 0.0032,
  fatigueRecoverOvernight: 0.42,
  disruptionPenaltySeconds: 8,
  baseMistakeChance: 0.028,
  overloadMistakeBoost: 0.06,
  mistakeTimePenalty: 6,
  mistakeQualityPenalty: 0.09,

  // Menu
  menu: [
    { id:"burger", name:"Burger & Chips",   price:24, cost:8.5,  steps:[["PREP",5],["COOK",10],["PASS",3]], baseQuality:0.86, tag:"Fast" },
    { id:"pasta",  name:"Pasta (Ragù)",     price:28, cost:9.5,  steps:[["PREP",6],["COOK",12],["PASS",3]], baseQuality:0.88, tag:"Comfort" },
    { id:"salad",  name:"Seasonal Salad",   price:20, cost:6.5,  steps:[["PREP",7],["PASS",2]],            baseQuality:0.90, tag:"Light" },
    { id:"steak",  name:"Steak Frites",     price:42, cost:15.5, steps:[["PREP",5],["COOK",16],["PASS",4]], baseQuality:0.84, tag:"Premium" },
  ]
};

/* -------------------- Layout Defaults -------------------- */
function defaultLayout(){
  return {
    diningRect: {x:70,y:70,w:640,h:360},
    kitchenRect:{x:70,y:450,w:640,h:200},
    entry:{x:750,y:120},
    tables: [
      {id:"T1", x:140,y:120,seats:2},
      {id:"T2", x:280,y:120,seats:2},
      {id:"T3", x:420,y:120,seats:2},
      {id:"T4", x:140,y:250,seats:2},
      {id:"T5", x:280,y:250,seats:2},
      {id:"T6", x:420,y:250,seats:2},
    ],
    stations: [
      {id:"P1", type:"PREP", x:170,y:525},
      {id:"C1", type:"COOK", x:360,y:525},
      {id:"X1", type:"PASS", x:550,y:525},
    ],
    expand: { floorLevel:0, kitchenLevel:0 }
  };
}

/* -------------------- State -------------------- */
const Game = {
  mode:"BUILD",        // BUILD or SERVICE or REPORT
  building:true,
  running:false,
  paused:false,
  speedIdx:0,
  speedList:[1,2,4],
  day:1,
  t:0,
  cash: 420,
  rating: 3.6,
  cleanliness: 0.92,
  janitors: 0,
  wageJanitorPerDay: 90,
  cooks: [],
  wageCookPerDay: 120,

  menuPrices: {},
  parPlan: {},
  carryStock: {},
  stock: {},
  outOfStock: new Set(),

  // derived at runtime
  tables: [],
  guests: [],
  tickets: [],
  stationsRuntime: {},

  stats: null,
  spawnAcc: 0,
  reportOpen: false,

  // layout (editable)
  layout: defaultLayout(),

  // build selection
  tool:"select",       // select, table, prep, cook, pass
  selected: null,      // {kind:"table"/"station", id}
  drag: null,
};

function dishById(id){ return DATA.menu.find(d=>d.id===id); }
function getPrice(d){
  const v = Game.menuPrices[d.id];
  return (typeof v==="number" && isFinite(v) && v>0) ? v : d.price;
}
function getPar(d){
  const v = Game.parPlan[d.id];
  return (typeof v==="number" && isFinite(v) && v>=0) ? Math.round(v) : 12;
}

/* -------------------- Staff Generation -------------------- */
const NAMES = ["Kai","Mina","Theo","Ava","Luca","Noah","Zoe","Isla","Jett","Sage","Aria","Milo","Nico","Ivy","Eli","Juno","Skye","Remi","Finn","Elsie"];
function randSkill(base=0.55, spread=0.25){
  return U.clamp(base + (Math.random()-0.5)*2*spread, 0.15, 0.95);
}
function createCook(){
  const id = "C"+U.uid();
  const name = U.pick(NAMES) + " " + U.pick(["P.","K.","R.","S.","T.","M.","L."]);
  const archetype = Math.random();
  let sPrep = randSkill(0.58,0.25), sCook = randSkill(0.58,0.25), sPass = randSkill(0.52,0.25);
  if(archetype < 0.33){ sCook = randSkill(0.70,0.18); }
  else if(archetype < 0.66){ sPrep = randSkill(0.70,0.18); }
  else { sPass = randSkill(0.68,0.20); }
  return { id, name, wage:Game.wageCookPerDay, assign:"COOK", skills:{PREP:sPrep, COOK:sCook, PASS:sPass}, fatigue:0 };
}
function ensureDefaultCooks(){
  if(Game.cooks.length === 0){
    Game.cooks.push(createCook(), createCook(), createCook());
    autoAssignStations(true);
  }
}
function cookSkillFactor(c, station){
  const s = U.clamp(c.skills[station] ?? 0.5, 0.1, 0.99);
  const base = 0.55 + s*0.85;  // 0.63..1.39
  const fatiguePenalty = 1 - (U.clamp(c.fatigue,0,1) * 0.45);
  return base * fatiguePenalty;
}
function stationCoverage(){
  const counts = {PREP:0, COOK:0, PASS:0, FLOAT:0};
  for(const c of Game.cooks){
    if(counts[c.assign] != null) counts[c.assign] += 1;
  }
  return counts;
}
function autoAssignStations(silent=false){
  for(const c of Game.cooks) c.assign = "FLOAT";
  const bestFor = (station)=>{
    let best=null, bestScore=-1;
    for(const c of Game.cooks){
      if(c.assign !== "FLOAT") continue;
      const sc = c.skills[station] ?? 0.5;
      if(sc > bestScore){ bestScore=sc; best=c; }
    }
    if(best) best.assign = station;
  };
  bestFor("PREP"); bestFor("COOK"); bestFor("PASS");
  saveGame();
  buildStaffUI();
  if(!silent) toast("Auto assigned stations.");
}
function changeAssignment(cookId, newStation){
  const c = Game.cooks.find(x=>x.id===cookId);
  if(!c || c.assign===newStation) return;
  c.assign = newStation;
  if(Game.running && !Game.reportOpen){
    Game._disruptionUntil = Math.max(Game._disruptionUntil||0, Game.t + DATA.disruptionPenaltySeconds);
    updateRating(-0.01);
    toast("Mid-service station change: disruption!");
  }
  saveGame();
}

/* -------------------- Economy & Rating -------------------- */
function freshStats(){
  return {
    served:0, left:0, revenue:0, costs:0, wages:0,
    waitTotal:0, waitCount:0, comped:0,
    prepCost:0, wasteCost:0,
    outEvents:0, emergency:0, mistakes:0,
    issues:{slow:0, dirty:0, value:0, out:0}
  };
}
function applyDailyWages(){
  const cookWages = Game.cooks.reduce((s,c)=>s + (c.wage||Game.wageCookPerDay), 0);
  const janWages = Game.janitors * Game.wageJanitorPerDay;
  const wages = cookWages + janWages;
  Game.cash -= wages;
  Game.stats.wages = wages;
}
function addRevenue(n){ Game.cash += n; Game.stats.revenue += n; }
function addCost(n){ Game.cash -= n; Game.stats.costs += n; }
function updateRating(delta){ Game.rating = U.clamp(Game.rating + delta, DATA.ratingFloor, DATA.ratingCeil); }
function foodCostPctToday(){
  const rev = Game.stats.revenue;
  if(rev <= 0) return 0;
  return (Game.stats.costs / rev) * 100;
}
function ratingFromSignals(avgWait, cleanliness, valueComplaints, outEvents, mistakes){
  const waitPenalty = U.clamp((avgWait - 18) / 45, 0, 1);
  const cleanBonus  = U.clamp((cleanliness - 0.75) / 0.25, 0, 1);
  const valuePenalty = U.clamp(valueComplaints / 10, 0, 1) * 0.55;
  const outPenalty = U.clamp(outEvents / 10, 0, 1) * 0.75;
  const mistakePenalty = U.clamp(mistakes / 12, 0, 1) * 0.65;
  const base = 2.65 + (cleanBonus*1.6) - (waitPenalty*1.5) - valuePenalty - outPenalty - mistakePenalty;
  return U.clamp(base, DATA.ratingFloor, DATA.ratingCeil);
}

/* -------------------- Prep/Stock -------------------- */
function estimatePrepCost(){
  let cost=0;
  for(const d of DATA.menu){
    const par = getPar(d);
    const carry = Math.round(Game.carryStock[d.id] ?? 0);
    cost += Math.max(0, par - carry) * d.cost;
  }
  return cost;
}
function doPrepToPar(){
  Game.stock = {};
  Game.outOfStock = new Set();
  let prepCost=0;
  for(const d of DATA.menu){
    const par = getPar(d);
    const carry = Math.round(Game.carryStock[d.id] ?? 0);
    const need = Math.max(0, par - carry);
    Game.stock[d.id] = carry + need;
    prepCost += need * d.cost;
  }
  if(prepCost > 0) addCost(prepCost);
  Game.stats.prepCost = prepCost;
}
function stockFor(id){ return Math.max(0, Math.round(Game.stock[id] ?? 0)); }
function endOfDaySpoilage(){
  let wasteCost=0;
  for(const d of DATA.menu){
    const left = stockFor(d.id);
    if(left<=0){ Game.carryStock[d.id]=0; continue; }
    const spoiled = Math.round(left * DATA.spoilRate);
    const carry = Math.max(0, left - spoiled);
    wasteCost += spoiled * d.cost;
    Game.carryStock[d.id]=carry;
  }
  if(wasteCost>0) addCost(wasteCost);
  Game.stats.wasteCost = wasteCost;
}

/* -------------------- Layout -> Runtime -------------------- */
function rebuildRuntimeFromLayout(){
  // tables runtime are derived from layout tables and occupied state
  Game.tables = Game.layout.tables.map(t=>({ id:t.id, x:t.x, y:t.y, seats:t.seats, occupied:0, party:null }));
}
function canSeatParty(size){ return Game.tables.some(t=>t.occupied===0 && t.seats>=size); }
function seatParty(p){
  const t = Game.tables.find(x=>x.occupied===0 && x.seats>=p.size);
  if(!t) return false;
  t.occupied = p.size; t.party = p.id;
  p.state="SEATED"; p.tableId=t.id; p.seatedAt=Game.t;
  return true;
}
function clearTable(id){ const t=Game.tables.find(x=>x.id===id); if(t){ t.occupied=0; t.party=null; } }

/* -------------------- Guests -------------------- */
function spawnGuestParty(){
  const size = Math.random() < 0.7 ? 2 : 1;
  const picky = Math.random() < 0.18;
  const patience = U.rand(38, 80) * (picky?0.85:1.0);
  const budget = U.rand(18, 55);
  const id = "G"+U.uid();
  const pref = U.pick(["Fast","Comfort","Light","Premium"]);
  Game.guests.push({ id,size,picky,patience,budget,pref, state:"WAITING", tableId:null, orderedAt:null, servedAt:null, dishId:null, satisfaction:1.0, note:"" });
}
function chooseDish(party, allowOut=false){
  const pool = DATA.menu
    .map(d=>({dish:d, price:getPrice(d), stock:stockFor(d.id)}))
    .filter(x=> allowOut ? true : (x.stock > 0));
  const pickFrom = pool.length ? pool : DATA.menu.map(d=>({dish:d, price:getPrice(d), stock:0}));

  const weighted=[];
  for(const {dish,price,stock} of pickFrom){
    let w=1;
    if(dish.tag===party.pref) w+=1.4;
    if(price>party.budget) w-=0.3;
    const fc = dish.cost / Math.max(1, price);
    const value = U.clamp(0.6 - (fc - 0.32), 0.25, 1.0);
    w += value*0.4;
    if(stock<=2 && !allowOut) w-=0.15;
    weighted.push([{dish,price}, Math.max(0.05,w)]);
  }
  let sum=0; for(const [,w] of weighted) sum+=w;
  let r=Math.random()*sum;
  for(const [obj,w] of weighted){ r-=w; if(r<=0) return obj.dish; }
  return pickFrom[0].dish;
}

/* -------------------- Physical Stations -------------------- */
function physCounts(){
  const c = {PREP:0, COOK:0, PASS:0};
  for(const s of Game.layout.stations){
    if(c[s.type]!=null) c[s.type] += 1;
  }
  return c;
}
function stationProfile(station){
  const assigned = Game.cooks.filter(c=>c.assign===station);
  const floats = Game.cooks.filter(c=>c.assign==="FLOAT");
  const floatWeight = 0.35;

  let capacityFloat=0, speedSum=0, head=0;
  for(const c of assigned){
    const f=cookSkillFactor(c, station);
    capacityFloat+=f; speedSum+=f; head+=1;
  }
  for(const c of floats){
    const f=cookSkillFactor(c, station)*floatWeight;
    capacityFloat+=f; speedSum+=f; head+=floatWeight;
  }

  const scramble = (assigned.length===0 && floats.length===0);
  const baseCap = scramble ? 0.75 : 0;
  capacityFloat = Math.max(baseCap, capacityFloat);

  let staffCap = Math.max(1, Math.floor(capacityFloat + 0.5));
  const avgSkill = (head>0) ? (speedSum/head) : (scramble ? 0.75 : 0.9);
  let speed = U.clamp(avgSkill / 1.15, 0.65, 1.25);

  // Physical cap (build mode)
  const pc = physCounts();
  const phys = pc[station] || 0;
  if(phys <= 0){
    // no physical station: you "improvise" (slow + error-prone)
    staffCap = 1;
    speed *= 0.58;
  }else{
    staffCap = Math.min(staffCap, phys);
    // a small boost if you have 2+ work surfaces (less congestion)
    const boost = U.clamp(0.92 + Math.min(phys,3)*0.03, 0.92, 1.02);
    speed *= boost;
  }

  return {capacity:staffCap, speed, phys};
}

/* -------------------- Kitchen Runtime -------------------- */
function initStationsRuntime(){
  Game.stationsRuntime = {};
  for(const s of DATA.stations){
    Game.stationsRuntime[s] = { id:s, queue:[], active:[], done:0, profile: stationProfile(s) };
  }
}
function refreshStationProfiles(){
  for(const s of DATA.stations){
    if(!Game.stationsRuntime[s]) Game.stationsRuntime[s] = { id:s, queue:[], active:[], done:0 };
    Game.stationsRuntime[s].profile = stationProfile(s);
  }
}
function ticketQualityEstimate(ticket){
  const wait = (Game.t - ticket.orderedAt);
  const waitFactor = U.clamp(1 - (wait-20)/80, 0.25, 1.0);
  const cleanFactor = U.clamp(0.7 + Game.cleanliness*0.4, 0.7, 1.1);
  const staffFactor = U.clamp(1 - (ticket.qualityPenalty||0), 0.6, 1.0);
  return U.clamp(ticket.baseQuality * waitFactor * cleanFactor * staffFactor, 0.2, 1.0);
}
function createTicket(party, dish, opts={}){
  const emergency = !!opts.emergency;
  const price = getPrice(dish);

  if(!emergency){
    Game.stock[dish.id] = Math.max(0, stockFor(dish.id) - 1);
    if(stockFor(dish.id) === 0) Game.outOfStock.add(dish.id);
  }else{
    addCost(dish.cost * 1.25);
    Game.stats.emergency += 1;
  }

  const steps = dish.steps.map(([station,time])=>({station, time, remaining:time, state:"QUEUED"}));
  if(emergency) steps.unshift({station:"PREP", time:9, remaining:9, state:"QUEUED", _rush:true});

  const t = {
    id:"K"+U.uid(),
    partyId:party.id,
    dishId:dish.id,
    dishName:dish.name,
    price,
    defaultPrice:dish.price,
    steps,
    stepIndex:0,
    orderedAt:Game.t,
    finishedAt:null,
    baseQuality:dish.baseQuality,
    status:"QUEUED",
    emergency,
    qualityPenalty:0,
    mistakes:0
  };
  Game.tickets.push(t);
  enqueueNextStep(t);
  return t;
}
function enqueueNextStep(ticket){
  const idx = ticket.stepIndex;
  if(idx >= ticket.steps.length){ ticket.status="READY"; ticket.finishedAt=Game.t; return; }
  const step = ticket.steps[idx];
  step.state="QUEUED";
  Game.stationsRuntime[step.station].queue.push({ticketId:ticket.id, stepIndex:idx});
  ticket.status="COOKING";
}
function computeMistakeChance(stationId){
  const st = Game.stationsRuntime[stationId];
  const prof = st.profile;
  const load = st.queue.length + st.active.length;
  const cap = Math.max(1, prof.capacity);
  const overload = U.clamp((load - cap) / (cap*2.5), 0, 1);

  const assigned = Game.cooks.filter(c=>c.assign===stationId || c.assign==="FLOAT");
  const avgFat = assigned.length ? (assigned.reduce((s,c)=>s+c.fatigue,0)/assigned.length) : 0.2;
  const skillBad = U.clamp(1.05 - prof.speed, 0, 0.6);

  let p = DATA.baseMistakeChance
        + overload * DATA.overloadMistakeBoost
        + avgFat * 0.05
        + skillBad * 0.05;

  if(prof.phys <= 0) p += 0.06;  // missing physical station
  if(Game._disruptionUntil && Game.t < Game._disruptionUntil) p += 0.03;
  return U.clamp(p, 0.01, 0.26);
}
function processStations(dt){
  refreshStationProfiles();

  for(const sid of DATA.stations){
    const st = Game.stationsRuntime[sid];
    const {capacity, speed} = st.profile;

    while(st.active.length < capacity && st.queue.length>0){
      const task = st.queue.shift();
      st.active.push({ ticketId:task.ticketId, stepIndex:task.stepIndex });
      const ticket = Game.tickets.find(t=>t.id===task.ticketId);
      if(ticket) ticket.steps[task.stepIndex].state="ACTIVE";
    }

    const mistakeChance = computeMistakeChance(sid);

    for(let i=st.active.length-1;i>=0;i--){
      const a = st.active[i];
      const ticket = Game.tickets.find(t=>t.id===a.ticketId);
      if(!ticket){ st.active.splice(i,1); continue; }
      const step = ticket.steps[a.stepIndex];
      if(!step){ st.active.splice(i,1); continue; }

      const rushSlow = step._rush ? 0.85 : 1.0;
      const disruptionSlow = (Game._disruptionUntil && Game.t < Game._disruptionUntil) ? 0.85 : 1.0;
      const globalSpeed = U.clamp(1.0 + (Game.cleanliness-0.85)*0.6, 0.75, 1.15);

      step.remaining -= dt * globalSpeed * speed * rushSlow * disruptionSlow;

      if(step.remaining <= 0){
        if(Math.random() < mistakeChance){
          ticket.mistakes += 1;
          Game.stats.mistakes += 1;
          ticket.qualityPenalty = U.clamp((ticket.qualityPenalty||0) + DATA.mistakeQualityPenalty, 0, 0.35);

          const penalty = DATA.mistakeTimePenalty * (sid==="COOK" ? 1.2 : 1.0);
          if(ticket.stepIndex < ticket.steps.length - 1){
            ticket.steps[ticket.stepIndex+1].time += penalty;
            ticket.steps[ticket.stepIndex+1].remaining += penalty;
          }else{
            step.remaining += penalty; step.time += penalty; step.state="ACTIVE";
            continue;
          }
        }

        step.state="DONE";
        st.done += 1;
        st.active.splice(i,1);
        ticket.stepIndex += 1;
        enqueueNextStep(ticket);
      }
    }
  }

  const activeByStation = {};
  for(const sid of DATA.stations) activeByStation[sid] = Game.stationsRuntime[sid].active.length;

  for(const c of Game.cooks){
    const station = c.assign;
    let work = 0;
    if(station==="FLOAT"){
      const totalActive = DATA.stations.reduce((s,st)=>s+(activeByStation[st]||0),0);
      work = U.clamp(totalActive/6, 0, 1) * 0.6;
    }else{
      work = U.clamp((activeByStation[station]||0)/2, 0, 1);
    }
    c.fatigue = U.clamp(c.fatigue + dt * DATA.fatigueGainPerSec * work, 0, 1);
  }
}
function finalizeReadyTickets(){
  for(const ticket of Game.tickets){
    if(ticket.status !== "READY" || ticket._served) continue;
    const party = Game.guests.find(g=>g.id===ticket.partyId);
    if(!party){ ticket._served=true; continue; }

    const wait = (ticket.finishedAt ?? Game.t) - ticket.orderedAt;
    Game.stats.waitTotal += wait; Game.stats.waitCount += 1;

    const quality = ticketQualityEstimate(ticket);
    let sat = quality;

    const late = wait > party.patience;
    if(late){ sat *= 0.55; Game.stats.issues.slow += 1; }
    if(Game.cleanliness < 0.55){ sat *= 0.78; Game.stats.issues.dirty += 1; }

    // value
    const priceIndex = ticket.price / Math.max(1, ticket.defaultPrice);
    const overPrice = Math.max(0, priceIndex - 1);
    const underPrice = Math.max(0, 1 - priceIndex);

    let valueMult = 1.0;
    if(overPrice > 0){
      const amp = (party.picky ? 1.25 : 1.0) * (ticket.price > party.budget ? 1.15 : 1.0);
      const qualityGap = U.clamp(0.9 - quality, 0, 0.7);
      valueMult *= U.clamp(1 - overPrice * (0.22 + qualityGap*0.25) * amp, 0.70, 1.0);
    }
    if(underPrice > 0) valueMult *= U.clamp(1 + underPrice*0.08, 1.0, 1.10);

    sat *= valueMult;
    if(valueMult < 0.88) Game.stats.issues.value += 1;

    if(ticket.mistakes >= 1) sat *= U.clamp(0.98 - ticket.mistakes*0.06, 0.75, 0.98);

    const refund = sat < 0.33;
    if(refund){
      Game.stats.comped += 1;
      updateRating(-0.08);
      party.note = party.note ? (party.note + " · Comped") : "Comped";
    }else{
      addRevenue(ticket.price);
      updateRating(+0.02);
      if(valueMult < 0.88) updateRating(-0.01);
    }

    party.servedAt = Game.t;
    party.state="EATING";
    party.satisfaction = sat;
    party._leaveAt = Game.t + U.rand(8,16);
    if(Math.random() < DATA.litterChance) Game.cleanliness = U.clamp(Game.cleanliness - 0.06, 0, 1);

    Game.stats.served += 1;
    ticket._served = true;

    if(sat > 0.75) updateRating(+0.02);
    if(sat < 0.5)  updateRating(-0.03);
  }
  Game.tickets = Game.tickets.filter(t=>!t._served || (Game.t - (t.finishedAt ?? Game.t) < 30));
}

/* -------------------- Service Loop -------------------- */
function startService(){
  // disable build
  Game.mode="SERVICE";
  Game.building=false;
  Game.running=true;
  Game.paused=false;
  Game.reportOpen=false;
  Game.t=0;
  Game.spawnAcc=0;
  Game.guests=[];
  Game.tickets=[];
  Game.stats=freshStats();
  Game._disruptionUntil = 0;

  // runtime layout derived
  rebuildRuntimeFromLayout();
  initStationsRuntime();

  applyDailyWages();
  doPrepToPar();

  toast("Service started.");
  saveGame();
}
function endService(){
  Game.running=false;
  Game.paused=false;
  Game.reportOpen=true;
  Game.mode="REPORT";

  endOfDaySpoilage();

  const avgWait = Game.stats.waitCount ? (Game.stats.waitTotal/Game.stats.waitCount) : 0;
  const target = ratingFromSignals(avgWait, Game.cleanliness, Game.stats.issues.value, Game.stats.outEvents, Game.stats.mistakes);
  Game.rating = U.clamp(U.lerp(Game.rating, target, 0.55), DATA.ratingFloor, DATA.ratingCeil);

  for(const c of Game.cooks){
    c.fatigue = U.clamp(c.fatigue * (1 - DATA.fatigueRecoverOvernight), 0, 1);
  }

  saveGame();
  toast("End of day report.");
}
function updateSim(dt){
  Game.cleanliness = U.clamp(Game.cleanliness - DATA.cleanlinessDecay*dt, 0, 1);
  if(Game.janitors>0) Game.cleanliness = U.clamp(Game.cleanliness + (0.0085*Game.janitors)*dt, 0, 1);

  // spawn based on table count
  const tableCount = Game.tables.length || 1;
  const capacityBoost = U.clamp(tableCount / 6, 0.6, 1.7);

  const ratingNorm = (Game.rating - DATA.ratingFloor) / (DATA.ratingCeil - DATA.ratingFloor);
  let spawn = (DATA.spawnBase + ratingNorm*0.18 + (Game.cleanliness-0.75)*0.12) * capacityBoost;
  spawn = U.clamp(spawn, DATA.spawnMin, DATA.spawnMax*1.25);

  Game.spawnAcc += spawn * dt;
  while(Game.spawnAcc >= 1){
    Game.spawnAcc -= 1;
    if(canSeatParty(2) || canSeatParty(1)) spawnGuestParty();
  }

  for(const party of Game.guests){
    if(party.state==="WAITING"){
      const waited = Game.t - (party._arrivedAt ?? (party._arrivedAt = Game.t));
      if(seatParty(party)) party._orderAt = Game.t + U.rand(2.5, 6.5);
      else if(waited > U.rand(14, 24)){
        party.state="LEFT"; Game.stats.left += 1; updateRating(-0.03); party.note="Left (no table)";
      }
    }

    if(party.state==="SEATED" && Game.t >= party._orderAt){
      let dish = chooseDish(party, false);
      if(stockFor(dish.id) <= 0) dish = chooseDish(party, true);

      party.dishId = dish.id;
      party.orderedAt = Game.t;
      party.state="ORDERED";

      if(stockFor(dish.id) <= 0){
        Game.stats.outEvents += 1;
        Game.stats.issues.out += 1;

        const willEmergency = Math.random() < 0.45;
        if(willEmergency){
          party.note="Emergency prep";
          createTicket(party, dish, {emergency:true});
        }else{
          const alt = chooseDish(party, false);
          if(alt && stockFor(alt.id) > 0){
            party.note="Reordered (86)";
            updateRating(-0.02);
            createTicket(party, alt, {emergency:false});
          }else{
            party.state="LEFT"; Game.stats.left += 1; updateRating(-0.06);
            party.note="Left (too many 86)";
            if(party.tableId) clearTable(party.tableId);
          }
        }
      }else{
        createTicket(party, dish, {emergency:false});
      }
    }

    if(party.state==="ORDERED"){
      const waited = Game.t - party.orderedAt;
      if(waited > party.patience*1.35){
        party.state="LEFT";
        Game.stats.left += 1;
        updateRating(-0.07);
        party.note = party.note || "Left (waited too long)";
        if(party.tableId) clearTable(party.tableId);
      }
    }

    if(party.state==="EATING" && Game.t >= party._leaveAt){
      party.state="DONE";
      if(party.tableId) clearTable(party.tableId);
    }
  }

  processStations(dt);
  finalizeReadyTickets();

  if(Game.t >= DATA.shiftSeconds) endService();
}

/* -------------------- Build Mode Logic -------------------- */
function setTool(t){
  Game.tool = t;
  document.querySelectorAll(".toolBtn").forEach(b=>{
    b.classList.toggle("active", b.getAttribute("data-tool")===t);
  });
}
function insideRect(x,y,r){ return x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h; }
function clampToRect(item, kind){
  const r = (kind==="table") ? Game.layout.diningRect : Game.layout.kitchenRect;
  const w = (kind==="table") ? 90 : 110;
  const h = (kind==="table") ? 60 : 60;
  item.x = U.clamp(item.x, r.x+6, r.x + r.w - w - 6);
  item.y = U.clamp(item.y, r.y+6, r.y + r.h - h - 6);
}
function pickItemAt(x,y){
  // stations top priority
  for(let i=Game.layout.stations.length-1;i>=0;i--){
    const s = Game.layout.stations[i];
    const w=120, h=70;
    if(x>=s.x && y>=s.y && x<=s.x+w && y<=s.y+h) return {kind:"station", id:s.id};
  }
  for(let i=Game.layout.tables.length-1;i>=0;i--){
    const t = Game.layout.tables[i];
    const w=90, h=60;
    if(x>=t.x && y>=t.y && x<=t.x+w && y<=t.y+h) return {kind:"table", id:t.id};
  }
  return null;
}
function getSelectedObj(){
  if(!Game.selected) return null;
  if(Game.selected.kind==="table") return Game.layout.tables.find(t=>t.id===Game.selected.id);
  if(Game.selected.kind==="station") return Game.layout.stations.find(s=>s.id===Game.selected.id);
  return null;
}
function selectItem(sel){
  Game.selected = sel;
  const obj = getSelectedObj();
  const propBox = document.getElementById("propBox");
  const btnDelete = document.getElementById("btnDelete");

  if(!obj){
    propBox.style.display="none";
    btnDelete.disabled = true;
    return;
  }
  propBox.style.display="";
  btnDelete.disabled = false;

  if(sel.kind==="table"){
    document.getElementById("propTitle").textContent = "Table "+obj.id;
    document.getElementById("propSub").textContent = "Dining";
    document.getElementById("propPill").textContent = obj.seats+" seats";
    document.getElementById("tableProps").style.display="";
    document.getElementById("stationProps").style.display="none";
    document.getElementById("inpSeats").value = String(obj.seats);
  }else{
    document.getElementById("propTitle").textContent = "Station "+obj.id;
    document.getElementById("propSub").textContent = "Kitchen";
    document.getElementById("propPill").textContent = obj.type;
    document.getElementById("stationTypePill").textContent = obj.type;
    document.getElementById("tableProps").style.display="none";
    document.getElementById("stationProps").style.display="";
  }
}
function addTableAt(x,y){
  const cost = DATA.costTable;
  if(Game.cash < cost){ toast("Not enough cash for a table."); return false; }
  if(!insideRect(x,y,Game.layout.diningRect)){ toast("Tables must be placed in dining."); return false; }
  Game.cash -= cost;
  const id = "T"+(Game.layout.tables.length+1);
  const t = {id, x:x-45, y:y-30, seats:2};
  clampToRect(t, "table");
  Game.layout.tables.push(t);
  saveGame();
  toast("Table added.");
  return true;
}
function addStationAt(type, x,y){
  const cost = (type==="PREP") ? DATA.costPrep : (type==="COOK" ? DATA.costCook : DATA.costPass);
  if(Game.cash < cost){ toast("Not enough cash for that station."); return false; }
  if(!insideRect(x,y,Game.layout.kitchenRect)){ toast("Stations must be placed in kitchen."); return false; }
  Game.cash -= cost;
  const prefix = type==="PREP" ? "P" : (type==="COOK" ? "C" : "X");
  const n = Game.layout.stations.filter(s=>s.type===type).length + 1;
  const id = prefix + n;
  const s = {id, type, x:x-60, y:y-35};
  clampToRect(s, "station");
  Game.layout.stations.push(s);
  saveGame();
  toast(type+" station added.");
  return true;
}
function deleteSelected(){
  if(!Game.selected) return;
  if(Game.selected.kind==="table"){
    const idx = Game.layout.tables.findIndex(t=>t.id===Game.selected.id);
    if(idx>=0) Game.layout.tables.splice(idx,1);
  }else{
    const idx = Game.layout.stations.findIndex(s=>s.id===Game.selected.id);
    if(idx>=0) Game.layout.stations.splice(idx,1);
  }
  Game.selected = null;
  selectItem(null);
  saveGame();
  toast("Deleted.");
}
function expandFloor(){
  const lvl = Game.layout.expand.floorLevel || 0;
  const cost = Math.round(DATA.expandFloorBase * Math.pow(DATA.expandMult, lvl));
  if(Game.cash < cost){ toast("Not enough cash to expand floor."); return; }
  Game.cash -= cost;
  Game.layout.expand.floorLevel = lvl + 1;

  // widen both dining + kitchen
  Game.layout.diningRect.w += 80;
  Game.layout.kitchenRect.w += 80;
  Game.layout.entry.x += 80;

  // clamp all items
  for(const t of Game.layout.tables) clampToRect(t,"table");
  for(const s of Game.layout.stations) clampToRect(s,"station");

  saveGame();
  toast("Floor expanded.");
}
function expandKitchen(){
  const lvl = Game.layout.expand.kitchenLevel || 0;
  const cost = Math.round(DATA.expandKitchenBase * Math.pow(DATA.expandMult, lvl));
  if(Game.cash < cost){ toast("Not enough cash to expand kitchen."); return; }
  Game.cash -= cost;
  Game.layout.expand.kitchenLevel = lvl + 1;

  Game.layout.kitchenRect.h += 60;
  saveGame();
  toast("Kitchen expanded.");
}

/* -------------------- UI: Staff -------------------- */
function buildStaffUI(){
  const el = document.getElementById("staffList");
  el.innerHTML = "";
  const cov = stationCoverage();
  const pc = physCounts();
  document.getElementById("staffPill").textContent = `Cooks ${Game.cooks.length} · Phys PREP ${pc.PREP} COOK ${pc.COOK} PASS ${pc.PASS}`;

  for(const c of Game.cooks){
    const sp=pct(c.skills.PREP), sc=pct(c.skills.COOK), sa=pct(c.skills.PASS), fat=pct(c.fatigue);
    el.insertAdjacentHTML("beforeend", `
      <div class="staff" data-id="${c.id}">
        <div class="staffTop">
          <div>
            <b>${c.name}</b>
            <div class="small">Wage $${c.wage}/day · Fatigue ${fat}%</div>
            <div class="small">Skills: PREP ${sp}% · COOK ${sc}% · PASS ${sa}%</div>
          </div>
          <div>
            <select data-act="assign">
              <option value="PREP" ${c.assign==="PREP"?"selected":""}>PREP</option>
              <option value="COOK" ${c.assign==="COOK"?"selected":""}>COOK</option>
              <option value="PASS" ${c.assign==="PASS"?"selected":""}>PASS</option>
              <option value="FLOAT" ${c.assign==="FLOAT"?"selected":""}>FLOAT</option>
            </select>
          </div>
        </div>
      </div>
    `);
  }
  el.querySelectorAll(".staff").forEach(node=>{
    const id=node.getAttribute("data-id");
    node.querySelector('[data-act="assign"]').addEventListener("change", (e)=>{
      changeAssignment(id, e.target.value);
      buildStaffUI();
    });
  });
}

/* -------------------- UI: Tickets -------------------- */
function updateTicketsUI(){
  const box = document.getElementById("tickets");
  const live = Game.tickets.filter(t=>!t._served).slice(0,12);
  box.innerHTML = live.length ? "" : `<div class="small">No tickets yet.</div>`;

  for(const t of live){
    const waited = Game.t - t.orderedAt;
    const prog = U.clamp((t.stepIndex) / (t.steps.length || 1), 0, 1);
    const q = ticketQualityEstimate(t);

    const warn = (waited>40 || q<0.55 || t.mistakes>0 || t.emergency) ? " style='border-color:#7a2d33;'" : "";
    box.insertAdjacentHTML("beforeend", `
      <div class="ticket"${warn}>
        <div class="top">
          <div><b>${t.dishName}</b><div class="small">Ticket ${t.id} · $${Math.round(t.price)}</div></div>
          <div style="text-align:right">
            <div class="small">Wait ${Math.round(waited)}s</div>
            <div class="small">Quality ${(q*100).toFixed(0)}%</div>
          </div>
        </div>
        <div class="bar"><div style="width:${(prog*100).toFixed(0)}%"></div></div>
        <div class="small" style="margin-top:6px;">
          Step ${Math.min(t.stepIndex+1, t.steps.length)}/${t.steps.length}
          — ${t.stepIndex < t.steps.length ? t.steps[t.stepIndex].station : "DONE"}
          · Mistakes ${t.mistakes}
          ${t.emergency ? " · emergency" : ""}
        </div>
      </div>
    `);
  }

  const outIds = Array.from(Game.outOfStock.values());
  const names = outIds.map(id=>dishById(id)?.name || id);
  document.getElementById("board86").textContent = names.length ? names.join(", ") : "None";
}

/* -------------------- UI: Global -------------------- */
function updateBuildUI(){
  const buildCard = document.getElementById("buildCard");
  buildCard.style.display = (Game.mode==="BUILD") ? "" : "none";

  const btnBuild = document.getElementById("btnBuildToggle");
  btnBuild.textContent = (Game.mode==="BUILD") ? "Exit Build" : "Enter Build";

  document.getElementById("modePill").textContent = Game.mode==="BUILD" ? "Build" : (Game.mode==="SERVICE" ? "Service" : "Report");
  document.getElementById("buildPill").textContent = Game.mode==="BUILD" ? "Editing" : "Locked";

  // expansion cost hints
  const fl = Game.layout.expand.floorLevel || 0;
  const kl = Game.layout.expand.kitchenLevel || 0;
  const fcost = Math.round(DATA.expandFloorBase * Math.pow(DATA.expandMult, fl));
  const kcost = Math.round(DATA.expandKitchenBase * Math.pow(DATA.expandMult, kl));
  document.getElementById("btnExpandFloor").textContent = `Expand Floor +80w (${U.fmtMoney(fcost)})`;
  document.getElementById("btnExpandKitchen").textContent = `Expand Kitchen +60h (${U.fmtMoney(kcost)})`;

  // Start service requires at least 1 table + 1 cook station + 1 pass + 1 prep (physically)
  const pc = physCounts();
  const ok = (Game.layout.tables.length >= 1) && (pc.COOK>=1) && (pc.PASS>=1) && (pc.PREP>=1);
  document.getElementById("btnStart").disabled = !(Game.mode!=="SERVICE" && ok);
}
function updateUI(){
  document.getElementById("cash").textContent = U.fmtMoney(Game.cash);
  document.getElementById("rating").textContent = U.star(Game.rating);
  document.getElementById("dayPill").textContent = String(Game.day);
  document.getElementById("speedText").textContent = Game.speedList[Game.speedIdx]+"×";

  const profit = Game.stats ? (Game.stats.revenue - Game.stats.costs - Game.stats.wages) : 0;
  document.getElementById("profitToday").textContent = U.fmtMoney(profit);

  const remain = Math.max(0, DATA.shiftSeconds - Game.t);
  const mm = String(Math.floor(remain/60)).padStart(2,"0");
  const ss = String(Math.floor(remain%60)).padStart(2,"0");
  document.getElementById("shiftTime").textContent = `${mm}:${ss}`;

  document.getElementById("btnPause").disabled = !(Game.mode==="SERVICE");
  document.getElementById("btnPause").textContent = Game.paused ? "Resume" : "Pause";
  document.getElementById("ticketCount").textContent = String(Game.tickets.filter(t=>!t._served).length);

  const pc = physCounts();
  document.getElementById("physPill").textContent = `Tables ${Game.layout.tables.length} · Phys PREP ${pc.PREP} COOK ${pc.COOK} PASS ${pc.PASS}`;

  updateBuildUI();
  updateTicketsUI();
}

/* -------------------- Save / Load (migration friendly) -------------------- */
function saveGame(){
  const save = {
    v:5,
    day:Game.day,
    cash:Game.cash,
    rating:Game.rating,
    cleanliness:Game.cleanliness,
    janitors:Game.janitors,
    menuPrices:Game.menuPrices,
    parPlan:Game.parPlan,
    carryStock:Game.carryStock,
    cooks:Game.cooks,
    layout:Game.layout
  };
  localStorage.setItem("rtycoon_save_v5", JSON.stringify(save));
  // keep v4 updated too (optional)
  localStorage.setItem("rtycoon_save_v4", JSON.stringify(save));
}
function loadGame(){
  const raw = localStorage.getItem("rtycoon_save_v5")
          || localStorage.getItem("rtycoon_save_v4")
          || localStorage.getItem("rtycoon_save_v3")
          || localStorage.getItem("rtycoon_save_v2")
          || localStorage.getItem("rtycoon_save_v1");
  if(!raw) return false;
  try{
    const s = JSON.parse(raw);
    Game.day = s.day ?? 1;
    Game.cash = s.cash ?? 420;
    Game.rating = s.rating ?? 3.6;
    Game.cleanliness = s.cleanliness ?? 0.92;
    Game.janitors = s.janitors ?? 0;
    Game.menuPrices = s.menuPrices ?? {};
    Game.parPlan = s.parPlan ?? {};
    Game.carryStock = s.carryStock ?? {};
    if(Array.isArray(s.cooks)){
      Game.cooks = s.cooks.map(c=>({
        id: c.id || ("C"+U.uid()),
        name: c.name || (U.pick(NAMES)+" "+U.pick(["P.","K.","R.","S.","T."])),
        wage: c.wage ?? Game.wageCookPerDay,
        assign: c.assign || "COOK",
        skills: c.skills || {PREP:0.55, COOK:0.55, PASS:0.55},
        fatigue: U.clamp(c.fatigue ?? 0, 0, 1)
      }));
    }else{
      Game.cooks = [];
    }

    // layout migration: if older saves don't have layout, use default
    if(s.layout && s.layout.diningRect && s.layout.kitchenRect){
      Game.layout = s.layout;
      if(!Game.layout.expand) Game.layout.expand = {floorLevel:0,kitchenLevel:0};
      if(!Array.isArray(Game.layout.tables)) Game.layout.tables = defaultLayout().tables;
      if(!Array.isArray(Game.layout.stations)) Game.layout.stations = defaultLayout().stations;
      if(!Game.layout.entry) Game.layout.entry = defaultLayout().entry;
    }else{
      Game.layout = defaultLayout();
    }

    return true;
  }catch{
    return false;
  }
}
function resetAll(){
  ["rtycoon_save_v5","rtycoon_save_v4","rtycoon_save_v3","rtycoon_save_v2","rtycoon_save_v1"].forEach(k=>localStorage.removeItem(k));
  Object.assign(Game, {
    mode:"BUILD", building:true, running:false, paused:false, speedIdx:0,
    day:1, t:0, cash:420, rating:3.6, cleanliness:0.92, janitors:0,
    menuPrices:{}, parPlan:{}, carryStock:{}, stock:{}, outOfStock:new Set(),
    guests:[], tickets:[], stationsRuntime:{}, stats:freshStats(), spawnAcc:0, reportOpen:false,
    layout: defaultLayout(),
    tool:"select", selected:null, drag:null
  });
  Game.cooks = [];
  ensureDefaultCooks();
  rebuildRuntimeFromLayout();
  initStationsRuntime();
  buildStaffUI();
  selectItem(null);
  toast("Reset complete.");
}

/* -------------------- Canvas Rendering -------------------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const w = Math.floor(rect.width * DPR);
  const h = Math.floor(rect.height * DPR);
  if(canvas.width !== w || canvas.height !== h){ canvas.width = w; canvas.height = h; }
}
window.addEventListener("resize", ()=>{ DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); resizeCanvas(); });

function draw(){
  resizeCanvas();
  const w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);

  // grid
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(123,220,255,0.10)";
  ctx.lineWidth = 1;
  const step = 28*DPR;
  for(let x=0;x<w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for(let y=0;y<h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.restore();

  const s=DPR;
  const L=Game.layout;

  function rect(r, fill, stroke){
    ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(r.x*s,r.y*s,r.w*s,r.h*s,14*s); ctx.fill(); ctx.stroke();
  }
  rect(L.diningRect, "rgba(27,42,77,0.35)", "rgba(123,220,255,0.18)");
  rect(L.kitchenRect,"rgba(31,59,43,0.35)", "rgba(124,255,138,0.16)");

  ctx.fillStyle="rgba(223,230,255,0.90)";
  ctx.font=`${14*s}px system-ui`;
  ctx.fillText("DINING", (L.diningRect.x+14)*s, (L.diningRect.y+24)*s);
  ctx.fillText("KITCHEN", (L.kitchenRect.x+14)*s, (L.kitchenRect.y+24)*s);

  // entry
  ctx.fillStyle="rgba(123,220,255,0.18)";
  ctx.strokeStyle="rgba(123,220,255,0.30)";
  ctx.lineWidth=2*s;
  ctx.beginPath(); ctx.roundRect((L.entry.x-20)*s,(L.entry.y-20)*s,160*s,70*s,14*s); ctx.fill(); ctx.stroke();
  ctx.fillStyle="rgba(223,230,255,0.85)";
  ctx.font=`${12*s}px system-ui`;
  ctx.fillText("ENTRY / QUEUE", (L.entry.x-8)*s, (L.entry.y+8)*s);

  // tables
  const tablesToDraw = (Game.mode==="SERVICE") ? Game.tables : Game.layout.tables;
  for(const t of tablesToDraw){
    const x=t.x*s, y=t.y*s;
    ctx.fillStyle="rgba(58,42,27,0.75)";
    ctx.strokeStyle="rgba(255,209,102,0.25)";
    if(Game.selected && Game.selected.kind==="table" && Game.selected.id===t.id) ctx.strokeStyle="rgba(123,220,255,0.85)";
    ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(x,y,90*s,60*s,10*s); ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(232,232,234,0.95)";
    ctx.font=`${12*s}px system-ui`;
    ctx.fillText(t.id, x+8*s, y+18*s);
    const occ = (Game.mode==="SERVICE") ? (t.occupied||0) : 0;
    const seats = t.seats || 2;
    for(let i=0;i<seats;i++){
      ctx.beginPath();
      const ox = x + (12+i*14)*s;
      const oy = y + 42*s;
      ctx.fillStyle = (i < occ) ? "rgba(123,220,255,0.95)" : "rgba(255,255,255,0.22)";
      ctx.arc(ox,oy,4.2*s,0,Math.PI*2); ctx.fill();
    }
  }

  // physical stations (build mode always, service too)
  for(const stn of Game.layout.stations){
    const x=stn.x*s, y=stn.y*s;
    ctx.fillStyle="rgba(59,31,52,0.70)";
    ctx.strokeStyle="rgba(255,107,107,0.22)";
    if(Game.selected && Game.selected.kind==="station" && Game.selected.id===stn.id) ctx.strokeStyle="rgba(123,220,255,0.85)";
    ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(x,y,120*s,70*s,12*s); ctx.fill(); ctx.stroke();
    ctx.fillStyle="rgba(232,232,234,0.95)";
    ctx.font=`${12*s}px system-ui`;
    ctx.fillText(`${stn.type}`, x+10*s, y+18*s);
    ctx.fillStyle="rgba(223,230,255,0.75)";
    ctx.fillText(`${stn.id}`, x+10*s, y+38*s);
  }

  // runtime station load overlays in service
  if(Game.mode==="SERVICE"){
    refreshStationProfiles();
    for(const sid of DATA.stations){
      const st = Game.stationsRuntime[sid];
      const prof = st.profile;
      const pc = physCounts();
      ctx.fillStyle="rgba(223,230,255,0.75)";
      ctx.font=`${12*s}px system-ui`;
      // show near kitchen header
      const bx = (L.kitchenRect.x + 16)*s;
      const by = (L.kitchenRect.y + 52 + (sid==="PREP"?0:(sid==="COOK"?18:36)))*s;
      ctx.fillText(`${sid}: cap ${prof.capacity} (phys ${pc[sid]||0}) · spd ${(prof.speed*100).toFixed(0)}% · Q ${st.queue.length} W ${st.active.length}`, bx, by);
    }
  }

  // guests
  if(Game.mode==="SERVICE"){
    for(const g of Game.guests){
      if(g.state==="LEFT" || g.state==="DONE") continue;
      let px=L.entry.x, py=L.entry.y;
      if(g.state==="WAITING"){
        const idx = Game.guests.filter(x=>x.state==="WAITING").indexOf(g);
        px = L.entry.x + (idx%6)*16;
        py = L.entry.y + 38 + Math.floor(idx/6)*16;
      }else if(g.tableId){
        const t = Game.tables.find(x=>x.id===g.tableId);
        if(t){ px = t.x + 58; py = t.y + 35; }
      }
      ctx.beginPath();
      ctx.fillStyle="rgba(36,49,82,0.95)";
      ctx.arc(px*s, py*s, 7*s, 0, Math.PI*2); ctx.fill();
      const mood = g.state==="ORDERED" ? (1 - U.clamp((Game.t - g.orderedAt)/g.patience,0,1)) : 1;
      ctx.strokeStyle = mood > 0.6 ? "rgba(124,255,138,0.85)" : (mood>0.3 ? "rgba(255,209,102,0.85)" : "rgba(255,107,107,0.85)");
      ctx.lineWidth=2*s; ctx.stroke();
    }
  }

  // cleanliness meter
  const meterX=(L.entry.x-10)*s, meterY=(L.entry.y+110)*s, meterW=320*s, meterH=18*s;
  ctx.fillStyle="rgba(15,20,38,0.9)";
  ctx.strokeStyle="rgba(43,51,80,0.9)";
  ctx.lineWidth=2*s;
  ctx.beginPath(); ctx.roundRect(meterX,meterY,meterW,meterH,999); ctx.fill(); ctx.stroke();
  ctx.fillStyle="rgba(123,220,255,0.85)";
  ctx.beginPath(); ctx.roundRect(meterX,meterY,meterW*Game.cleanliness,meterH,999); ctx.fill();
  ctx.fillStyle="rgba(223,230,255,0.85)";
  ctx.font=`${12*s}px system-ui`;
  ctx.fillText("Cleanliness", meterX, meterY-6*s);

  // build helper overlay
  if(Game.mode==="BUILD"){
    ctx.fillStyle="rgba(223,230,255,0.75)";
    ctx.font=`${12*s}px system-ui`;
    ctx.fillText(`Tool: ${Game.tool.toUpperCase()} (tap to place, drag to move)`, (L.entry.x-10)*s, (L.entry.y+170)*s);
  }

  // report overlay
  if(Game.reportOpen){
    ctx.fillStyle="rgba(7,8,16,0.80)";
    ctx.fillRect(0,0,w,h);

    const pad=30*s;
    ctx.fillStyle="rgba(223,230,255,0.95)";
    ctx.font=`${22*s}px system-ui`;
    ctx.fillText(`End of Day ${Game.day} Report`, pad, pad+10*s);

    const avgWait = Game.stats.waitCount ? (Game.stats.waitTotal/Game.stats.waitCount) : 0;
    const profit = Game.stats.revenue - Game.stats.costs - Game.stats.wages;
    const fc = foodCostPctToday();
    const avgFat = Game.cooks.length ? (Game.cooks.reduce((s,c)=>s+c.fatigue,0)/Game.cooks.length) : 0;

    const lines = [
      ["Revenue", U.fmtMoney(Game.stats.revenue)],
      ["Costs (prep+waste+emergency)", "-"+U.fmtMoney(Game.stats.costs)],
      ["Wages", "-"+U.fmtMoney(Game.stats.wages)],
      ["Profit", U.fmtMoney(profit)],
      ["Food Cost %", (Game.stats.revenue>0 ? fc.toFixed(1) : "0.0")+"%"],
      ["Served", String(Game.stats.served)],
      ["Left", String(Game.stats.left)],
      ["Avg Wait", Math.round(avgWait)+"s"],
      ["86 Events", String(Game.stats.outEvents)],
      ["Emergency", String(Game.stats.emergency)],
      ["Mistakes", String(Game.stats.mistakes)],
      ["Avg Fatigue", pct(avgFat)+"%"],
      ["Cleanliness", pct(Game.cleanliness)+"%"],
      ["Rating", U.star(Game.rating)]
    ];

    ctx.font=`${14*s}px system-ui`;
    let y = pad + 50*s;
    for(const [k,v] of lines){
      ctx.fillStyle="rgba(166,166,173,0.95)"; ctx.fillText(k, pad, y);
      ctx.fillStyle="rgba(223,230,255,0.95)"; ctx.fillText(v, pad + 320*s, y);
      y += 22*s;
      if(y > h - 70*s) break;
    }

    ctx.fillStyle="rgba(123,220,255,0.95)";
    ctx.fillText("Tap / click anywhere to return to Build Mode (next day)", pad, h - 40*s);
  }
}

/* -------------------- Canvas Interaction (Build) -------------------- */
function toWorld(px,py){
  const rect = canvas.getBoundingClientRect();
  const x = (px - rect.left) * (canvas.width / rect.width) / DPR;
  const y = (py - rect.top) * (canvas.height / rect.height) / DPR;
  return {x,y};
}
canvas.addEventListener("pointerdown", (e)=>{
  const p = toWorld(e.clientX, e.clientY);

  if(Game.reportOpen){
    Game.day += 1;
    Game.reportOpen = false;
    Game.mode="BUILD";
    Game.building=true;
    Game.cleanliness = U.clamp(Game.cleanliness + 0.10, 0, 1);
    saveGame();
    buildStaffUI();
    toast("New day. Build + staff + then start service.");
    return;
  }

  if(Game.mode !== "BUILD") return;

  const hit = pickItemAt(p.x, p.y);

  if(Game.tool === "select"){
    selectItem(hit);
    if(hit){
      const obj = getSelectedObj();
      if(obj){
        const offsetX = p.x - obj.x;
        const offsetY = p.y - obj.y;
        Game.drag = { kind: hit.kind, id: hit.id, offsetX, offsetY };
        canvas.setPointerCapture(e.pointerId);
      }
    }else{
      Game.drag = null;
    }
    return;
  }

  // place tools
  if(Game.tool === "table"){
    const ok = addTableAt(p.x, p.y);
    if(ok){ setTool("select"); selectItem({kind:"table", id: Game.layout.tables[Game.layout.tables.length-1].id}); }
    return;
  }
  if(Game.tool === "prep"){
    const ok = addStationAt("PREP", p.x, p.y);
    if(ok){ setTool("select"); selectItem({kind:"station", id: Game.layout.stations[Game.layout.stations.length-1].id}); }
    return;
  }
  if(Game.tool === "cook"){
    const ok = addStationAt("COOK", p.x, p.y);
    if(ok){ setTool("select"); selectItem({kind:"station", id: Game.layout.stations[Game.layout.stations.length-1].id}); }
    return;
  }
  if(Game.tool === "pass"){
    const ok = addStationAt("PASS", p.x, p.y);
    if(ok){ setTool("select"); selectItem({kind:"station", id: Game.layout.stations[Game.layout.stations.length-1].id}); }
    return;
  }
});

canvas.addEventListener("pointermove", (e)=>{
  if(Game.mode !== "BUILD") return;
  if(!Game.drag) return;
  const p = toWorld(e.clientX, e.clientY);
  const obj = getSelectedObj();
  if(!obj) return;

  obj.x = p.x - Game.drag.offsetX;
  obj.y = p.y - Game.drag.offsetY;
  clampToRect(obj, Game.drag.kind);
  saveGame();
});

canvas.addEventListener("pointerup", (e)=>{
  if(Game.mode !== "BUILD") return;
  if(Game.drag){
    Game.drag = null;
    try{ canvas.releasePointerCapture(e.pointerId); }catch{}
  }
});

/* -------------------- Build Props UI -------------------- */
document.getElementById("btnSeatsMinus").addEventListener("click", ()=>{
  const obj=getSelectedObj(); if(!obj || Game.selected.kind!=="table") return;
  obj.seats = U.clamp((obj.seats||2)-1, 1, 6);
  document.getElementById("inpSeats").value = String(obj.seats);
  document.getElementById("propPill").textContent = obj.seats+" seats";
  saveGame();
});
document.getElementById("btnSeatsPlus").addEventListener("click", ()=>{
  const obj=getSelectedObj(); if(!obj || Game.selected.kind!=="table") return;
  obj.seats = U.clamp((obj.seats||2)+1, 1, 6);
  document.getElementById("inpSeats").value = String(obj.seats);
  document.getElementById("propPill").textContent = obj.seats+" seats";
  saveGame();
});
document.getElementById("inpSeats").addEventListener("change", ()=>{
  const obj=getSelectedObj(); if(!obj || Game.selected.kind!=="table") return;
  obj.seats = U.clamp(Number(document.getElementById("inpSeats").value)||2, 1, 6);
  document.getElementById("propPill").textContent = obj.seats+" seats";
  saveGame();
});
document.getElementById("btnDelete").addEventListener("click", ()=>{ if(Game.mode==="BUILD") deleteSelected(); });

/* -------------------- Controls -------------------- */
document.querySelectorAll(".toolBtn").forEach(btn=>{
  btn.addEventListener("click", ()=> setTool(btn.getAttribute("data-tool")));
});
document.getElementById("btnExpandFloor").addEventListener("click", ()=>{ if(Game.mode==="BUILD") expandFloor(); });
document.getElementById("btnExpandKitchen").addEventListener("click", ()=>{ if(Game.mode==="BUILD") expandKitchen(); });

document.getElementById("btnBuildToggle").addEventListener("click", ()=>{
  if(Game.mode==="SERVICE"){ toast("Can't build during service."); return; }
  if(Game.mode==="REPORT"){ toast("Finish report (tap canvas)."); return; }
  Game.mode = (Game.mode==="BUILD") ? "BUILD" : "BUILD";
  Game.building = true;
  toast("Build mode.");
});

document.getElementById("btnStart").addEventListener("click", ()=>{
  if(Game.mode==="SERVICE"){ return; }
  const pc = physCounts();
  if(Game.layout.tables.length < 1 || pc.PREP<1 || pc.COOK<1 || pc.PASS<1){
    toast("Need tables + PREP + COOK + PASS stations.");
    return;
  }
  startService();
});
document.getElementById("btnPause").addEventListener("click", ()=>{
  if(Game.mode!=="SERVICE") return;
  Game.paused = !Game.paused;
});
document.getElementById("btnSpeed").addEventListener("click", ()=>{ Game.speedIdx = (Game.speedIdx+1) % Game.speedList.length; });
document.getElementById("btnReset").addEventListener("click", ()=>resetAll());

document.getElementById("btnHireCook").addEventListener("click", ()=>{
  Game.cooks.push(createCook());
  toast("Hired a cook.");
  autoAssignStations(true);
  saveGame();
  buildStaffUI();
});
document.getElementById("btnHireJanitor").addEventListener("click", ()=>{
  Game.janitors += 1;
  toast("Hired a janitor.");
  saveGame();
});
document.getElementById("btnAutoAssign").addEventListener("click", ()=>autoAssignStations(false));

/* -------------------- Main Loop -------------------- */
let last = U.now();
function loop(){
  const now = U.now();
  let dt = now - last;
  last = now;
  dt = U.clamp(dt, 0, 0.05);

  if(Game.mode==="SERVICE" && Game.running && !Game.paused){
    const speed = Game.speedList[Game.speedIdx];
    const sdt = dt * speed;
    Game.t += sdt;
    updateSim(sdt);
  }

  if(!Game.stats) Game.stats = freshStats();

  updateUI();
  draw();
  requestAnimationFrame(loop);
}

/* -------------------- Boot -------------------- */
(function boot(){
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    }
  }
  Game.stats = freshStats();
  loadGame();
  ensureDefaultCooks();

  // defaults for pars
  for(const d of DATA.menu){
    if(!(d.id in Game.parPlan)) Game.parPlan[d.id]=12;
    if(!(d.id in Game.carryStock)) Game.carryStock[d.id]=0;
  }

  rebuildRuntimeFromLayout();
  initStationsRuntime();
  buildStaffUI();
  selectItem(null);
  setTool("select");

  Game.mode="BUILD";
  toast("Stage 5 loaded: Build your layout, then Start Service.");
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
