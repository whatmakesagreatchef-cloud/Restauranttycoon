<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Restaurant Tycoon ‚Äî Build/Operate v2.2.0</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#171a21; --panel2:#11131a; --text:#e8e8ea; --muted:#a6a6ad;
      --accent:#7bdcff; --good:#7CFF8A; --bad:#ff6b6b; --warn:#ffd166;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    .wrap{ display:flex; min-height:100vh; gap:10px; padding:10px; }
    .left{ flex:1 1 auto; min-width:0; }
    .right{ width:480px; max-width:54vw; display:flex; flex-direction:column; gap:10px; }
    .card{ background:linear-gradient(180deg,var(--panel),#121522); border:1px solid #262b40; border-radius:12px; overflow:hidden; }
    .card h2{ margin:0; padding:10px 12px; font-size:13px; letter-spacing:.2px; color:#dfe6ff; background:linear-gradient(180deg,#1d2233,#141828); border-bottom:1px solid #262b40; display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .card .body{ padding:10px 12px; }
    canvas{ width:100%; height:calc(100vh - 20px); border-radius:12px; background:radial-gradient(1200px 700px at 30% 20%, #141a2a 0%, #0b0d14 40%, #070810 100%); border:1px solid #262b40; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; }
    button{ background:#1c2336; color:var(--text); border:1px solid #2b3350; padding:8px 10px; border-radius:10px; cursor:pointer; }
    button:hover{ border-color:#3a4780; }
    button.primary{ background:linear-gradient(180deg,#243152,#1a2340); border-color:#4253a3; }
    button.danger{ background:linear-gradient(180deg,#3a1f23,#2a1719); border-color:#7a2d33; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#0f1426; border:1px solid #2b3350; color:#dfe6ff; font-size:12px; }
    .kpi{ display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    .kpi .box{ background:var(--panel2); border:1px solid #262b40; border-radius:12px; padding:8px; }
    .kpi .box .label{ color:var(--muted); font-size:12px; }
    .kpi .box .value{ font-size:16px; margin-top:2px; }
    .small{ color:var(--muted); font-size:12px; }
    .tickets,.reviews,.bookings,.regulars{ max-height:150px; overflow:auto; padding-right:6px; }
    .ticket,.review,.booking,.regular{ border:1px solid #262b40; background:#0f1426; border-radius:12px; padding:8px; margin-bottom:8px; }
    .ticket .top,.review .top,.booking .top,.regular .top{ display:flex; justify-content:space-between; gap:8px; align-items:flex-start; }
    .bar{ height:8px; border-radius:999px; background:#0b0f1f; border:1px solid #262b40; overflow:hidden; margin-top:6px; }
    .bar > div{ height:100%; width:50%; background:linear-gradient(90deg,#7bdcff,#7cffc8); }
    .hr{ height:1px; background:#262b40; margin:10px 0; }
    .menutable{ width:100%; border-collapse:separate; border-spacing:0 6px; }
    .menutable th{ text-align:left; color:var(--muted); font-size:12px; font-weight:600; padding:0 6px; }
    .menutable td{ background:#0f1426; border:1px solid #262b40; padding:8px 6px; font-size:12px; }
    .menutable tr td:first-child{ border-radius:10px 0 0 10px; }
    .menutable tr td:last-child{ border-radius:0 10px 10px 0; }
    .pricebox{ display:flex; gap:6px; align-items:center; }
    .pricebox input{
      width:76px; padding:6px 8px; border-radius:10px; border:1px solid #2b3350;
      background:#0b0f1f; color:var(--text); font-size:12px;
    }
    .miniBtn{ padding:6px 8px; border-radius:10px; font-size:12px; }
    .warnTxt{ color:var(--warn); }
    .badTxt{ color:var(--bad); }
    .goodTxt{ color:var(--good); }
    .toast{ position:fixed; left:50%; transform:translateX(-50%); bottom:14px; background:#0f1426; border:1px solid #2b3350; border-radius:999px; padding:8px 12px; color:#dfe6ff; font-size:12px; opacity:0; transition:opacity .2s; pointer-events:none;}
    .toast.show{ opacity:1; }
    .stars{ color:#ffd166; letter-spacing:1px; }
    .tag{ font-size:11px; color:#dfe6ff; background:#0b0f1f; border:1px solid #2b3350; padding:2px 6px; border-radius:999px; display:inline-flex; gap:6px; align-items:center; }
    .legend{ display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .toggle{ display:flex; align-items:center; gap:8px; }
    .toggle input{ transform:scale(1.1); }
    .canvasWrap{
  border:1px solid #262b40;
  border-radius:12px;
  overflow:hidden;
  background:radial-gradient(1100px 700px at 20% 10%, #1a2a3a 0%, #0b0d14 40%, #070810 100%);
}
.canvasWrap canvas{
  display:block;
  border:0;
  background:transparent;
}

@media (max-width: 900px){
  .wrap{ flex-direction:column; }
  .right{ width:auto; max-width:none; }
  .canvasWrap{
    height:58vh;
    overflow:auto;
    -webkit-overflow-scrolling: touch;
  }
  canvas{
    width:930px;   /* world width */
    height:660px;  /* world height */
  }
}
      .right{ width:auto; max-width:none; }
      canvas{ height:52vh; }
    }
  .grid{ display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:8px; }
.tblBtn{ padding:10px; border-radius:12px; border:1px solid #2a3050; background:#0f1320; color:var(--text); cursor:pointer; }
.tblBtn.off{ opacity:.55; border-style:dashed; }
.tblBtn small{ display:block; opacity:.8; margin-top:4px; }
@media (max-width: 900px){
  .grid{ grid-template-columns: repeat(3, minmax(0,1fr)); }
}

</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="canvasWrap">
      <canvas id="c" width="1100" height="700" aria-label="Restaurant map"></canvas>
    </div>
  </div>

  <div class="right">
    <div class="card">
      <h2>
        <span>Restaurant Tycoon ‚Äî v2.2.0</span>
        <span class="pill" id="dayPill">Day 1</span>
      </h2>
<div class="row" id="modeRow" style="margin-top:10px;">
  <button id="btnModeBuild">Build</button>
  <button class="primary" id="btnModeOperate">Operate</button>
  <span class="pill" id="modePill">OPERATE</span>
</div>
<div class="body">
        <div class="row" style="align-items:center; justify-content:space-between;">
          <div class="pill">Shift: <span id="shiftTime">03:20</span></div>
          <div class="pill">Speed: <span id="speedText">1√ó</span></div>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="primary" id="btnStart">Start Service</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnSpeed">Speed Up</button>
          <button id="btnRush">Rush (test)</button>
          <button class="danger" id="btnReset">Reset</button>
        </div>

        <div class="row" style="margin-top:8px;">
          <span class="pill">Door Queue: <span id="queueLen">0</span></span>
          <span class="pill" id="overbookPill">Overbooking: none</span>
          <span class="pill" id="skillPill">Skill: 1.00/1.00</span>
          <span class="pill" id="moneyPill">Tips: $0 ¬∑ Comps: $0</span>
        </div>

        <div class="hr"></div>

        <div class="kpi">
          <div class="box"><div class="label">Cash</div><div class="value" id="cash">$0</div></div>
          <div class="box"><div class="label">Rating</div><div class="value" id="rating">0.0‚òÖ</div></div>
          <div class="box"><div class="label">Heads Served</div><div class="value" id="served">0</div></div>
          <div class="box"><div class="label">Avg Ticket Time</div><div class="value" id="avgWait">0s</div></div>
          <div class="box"><div class="label">Profit Today</div><div class="value" id="profitToday">$0</div></div>
          <div class="box"><div class="label">Food Cost</div><div class="value" id="foodCostPct">0%</div></div>
        </div>

        <div class="row" style="margin-top:8px;">
          <span class="pill">Door Queue: <span id="queueLen">0</span></span>
          <span class="pill" id="overbookPill">Overbooking: none</span>
          <span class="pill" id="skillPill">Skill: 1.00/1.00</span>
          <span class="pill" id="moneyPill">Tips: $0 ¬∑ Comps: $0</span>
        </div>

        <div class="hr"></div>

        <div class="row">
          <button id="btnHireCook">Hire Cook (+$120/day)</button>
          <button id="btnHireCleaner">Hire Cleaner (+$90/day)</button>
        </div>
        <div class="row">
          <button id="btnHireServer">Hire Server (+$110/day)</button>
          <button id="btnHireRunner">Hire Runner (+$95/day)</button>
        </div>
        <div class="row">
          <button id="btnHireBartender">Hire Bartender (+$100/day)</button>
          <button id="btnTrain">Training (+$250)</button>
        </div>

        <div class="row" style="margin-top:6px;">
          <label class="toggle small">
            <input type="checkbox" id="walkinsToggle" checked />
            Accept walk-ins
          </label>
          <span class="pill">Pacing: Hold tables for bookings</span>
        </div>

        <div class="legend small">
          <span class="tag">Guests: R / F / ‚òÖ</span><span class="tag">HQ = Host</span><span class="tag">Q = Queue</span>
          <span class="tag">Staff: SV / RN / CL</span>
          <span class="tag">B = Booking</span>
          <span class="tag">‚è± Hold</span><span class="tag">$ Pay</span><span class="tag">86 Stockout</span><span class="tag">DR = Drink ticket</span><span class="tag">üî• Refire/Comp</span><span class="tag">üí∏ Tips</span><span class="tag">üßæ Split</span><span class="tag">üí≥ EFTPOS</span><span class="tag">üò§ Complaints</span>
          <span class="tag">‚ù§ Regular</span>
        </div>

        <div class="small" style="margin-top:8px;">
          New: <b>Complaints</b> you can resolve mid-service + <b>split bills & EFTPOS delays</b> + <b>runner prioritises drinks</b>.
        </div>
      
<div class="card" id="buildCard" style="display:none;">
  <h2><span>Build Mode</span><span class="pill" id="buildPill">Day 0</span></h2>
  <div class="body">
    <div class="small">Spend cash to expand seating and upgrade stations. Build mode is best used <b>between services</b>.</div>

    <div class="row" style="margin-top:10px;">
      <div class="stat">
        <div class="k">Open Tables</div>
        <div class="v" id="openTablesTxt">0</div>
      </div>
      <div class="stat">
        <div class="k">Kitchen Lv</div>
        <div class="v" id="kitchenLvTxt">0</div>
      </div>
      <div class="stat">
        <div class="k">Bar Lv</div>
        <div class="v" id="barLvTxt">0</div>
      </div>
      <div class="stat">
        <div class="k">Decor Lv</div>
        <div class="v" id="decorLvTxt">0</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px; flex-wrap:wrap;">
      <button id="btnAddTable">Add Table (+$200)</button>
      <button id="btnRemoveTable">Remove Table (+$120)</button>
      <button id="btnUpKitchen">Upgrade Kitchen (+$350)</button>
      <button id="btnUpBar">Upgrade Bar (+$300)</button>
      <button id="btnUpDecor">Upgrade Decor (+$250)</button>
    </div>

    <div class="small" style="margin-top:10px;">Tap tables to open/close them:</div>
    <div class="grid" id="tableToggles"></div>

    <div class="row" style="margin-top:10px;">
      <button class="primary" id="btnJumpDining">Jump: Dining</button>
      <button class="primary" id="btnJumpKitchen">Jump: Kitchen</button>
      <button class="primary" id="btnJumpDoor">Jump: Door</button>
    </div>
  </div>
</div></div>
    </div>

    <div class="card">
      <h2><span>Bookings</span><span class="pill" id="bookingPill">0</span></h2>
      <div class="body">
        <div class="bookings" id="bookings"></div>
        <div class="small">Tables get held when a booking is near (‚è±). If they no-show, the hold releases.</div>
      </div>
    </div>

    <div class="card">
      <h2><span>Regulars</span><span class="pill" id="regularPill">0</span></h2>
      <div class="body">
        <div class="regulars" id="regulars"></div>
        <div class="small">Serve regulars well and they return more often (‚ù§). Bad service lowers loyalty.</div>
      </div>
    </div>

    <div class="card">
      <h2><span>Menu & Pricing</span><span class="pill">Target FC 28‚Äì35%</span></h2>
      <div class="body">
        <table class="menutable" aria-label="Menu pricing table">
          <thead>
            <tr>
              <th style="width:40%;">Dish</th>
              <th style="width:20%;">Price</th>
              <th style="width:20%;">Profit</th>
              <th style="width:20%;">Food%</th><th style="width:20%;">Stock</th>
            </tr>
          </thead>
          <tbody id="menuRows"></tbody>
        </table>
        <div class="small">Regulars tend to order their favourite dish (unless you priced it out).</div>
        <div class="hr"></div>
        <div class="small"><b>86 Board:</b> <span id="eightySix">None</span></div>
      </div>
    </div>

    <div class="card">
      <h2><span>Live Tickets</span><span class="pill" id="ticketCount">0</span></h2>
      <div class="body">
        <div class="tickets" id="tickets"></div>
        <div class="small">Tickets print when the <b>server</b> takes the order. Runner delivers. Payment happens after eating.</div>
      </div>
    </div>

    <div class="card">
      <h2><span>Reviews</span><span class="pill" id="reviewCount">0</span></h2>
      <div class="body">
        <div class="reviews" id="reviews"></div>
        <div class="small">Regular reviews affect return-rate. Critics affect rating harder.</div>
      </div>
    </div>
  </div>
</div>

<div class="card">
  <h2><span>Complaints</span><span class="pill" id="complaintPill">0</span></h2>
  <div class="body">
    <div class="bookings" id="complaints"></div>
    <div class="small">Tap <b>Apology</b> (no cost) or <b>Comp 15%</b> (costs margin) to save reviews.</div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>

function showFatalError(err){
  try{
    const msg = (err && (err.name||err.message)) ? (String(err.name||'Error')+': '+String(err.message||err)) : String(err);
    const stack = (err && err.stack) ? err.stack : '';
    console.error(err);
    const div=document.createElement("div");
    div.style.position="fixed";
    div.style.left="10px";
    div.style.right="10px";
    div.style.bottom="10px";
    div.style.zIndex="99999";
    div.style.padding="10px 12px";
    div.style.background="#1b1b1b";
    div.style.color="#fff";
    div.style.border="1px solid rgba(255,255,255,.25)";
    div.style.borderRadius="10px";
    div.style.fontFamily="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    div.style.fontSize="12px";
    div.innerHTML = "<b>Game error (JS stopped)</b><div style='opacity:.9;margin-top:6px;'>" + msg.replace(/</g,'&lt;') + "</div>" + (stack? ("<div style='opacity:.8;margin-top:6px;white-space:pre-wrap;max-height:160px;overflow:auto;'>"+ stack.replace(/</g,'&lt;') +"</div>") : "");
    document.body.appendChild(div);
  }catch(e){}
}
window.addEventListener("error", (e)=>showFatalError(e.error||e.message||e));
window.addEventListener("unhandledrejection", (e)=>showFatalError(e.reason||e));


/* ============================================================
   Restaurant Tycoon ‚Äî Single File (v2.1)
   Adds:
   - Table pacing: holds best-fit tables for upcoming bookings
   - Returning regulars: persistent customer memory (fave dish + loyalty)
   ============================================================ */

const U = {
  clamp:(v,a,b)=>Math.max(a,Math.min(b,v)),
  fmtMoney:(n)=>"$"+Math.round(n).toLocaleString(),
  now:()=>performance.now()/1000,
  rand:(a,b)=>a+Math.random()*(b-a),
  pick:(arr)=>arr[(Math.random()*arr.length)|0],
  uid:()=>Math.random().toString(36).slice(2,9),
  star:(r)=> (Math.round(r*10)/10).toFixed(1)+"‚òÖ",
  moveTowards:(pos, target, speed, dt)=>{
    const dx = target.x - pos.x, dy = target.y - pos.y;
    const d = Math.hypot(dx,dy) || 1;
    const step = Math.min(d, speed*dt);
    pos.x += dx/d * step;
    pos.y += dy/d * step;
    return (d - step) <= 0.5;
  }
};

function toast(msg){
  const el = document.getElementById("toast");
  el.textContent = msg;
  el.classList.add("show");
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>el.classList.remove("show"), 1400);
}

/* -------------------- Data -------------------- */
const DATA = {
  shiftSeconds: 210,
  spawnBase: 0.32,
  spawnMin: 0.08,
  spawnMax: 0.80,
  cleanlinessDecay: 0.0029,
  litterChance: 0.030,
  ratingFloor: 1.5,
  ratingCeil: 5.0,
  stations: ["PREP","COOK","BAR","PASS"],
  
  foodMenu: [
    { id:"burger", name:"Burger & Chips", priceBase:24, cost:8.5,  steps:[["PREP",5],["COOK",10],["PASS",3]], baseQuality:0.86, tag:"Fast" },
    { id:"pasta",  name:"Pasta (Rag√π)",  priceBase:28, cost:9.5,  steps:[["PREP",6],["COOK",12],["PASS",3]], baseQuality:0.88, tag:"Comfort" },
    { id:"salad",  name:"Seasonal Salad",priceBase:20, cost:6.5,  steps:[["PREP",7],["PASS",2]],           baseQuality:0.90, tag:"Light" },
    { id:"steak",  name:"Steak Frites",  priceBase:42, cost:15.5, steps:[["PREP",5],["COOK",16],["PASS",4]], baseQuality:0.84, tag:"Premium" },
  ],
  drinkMenu: [
    { id:"soda",     name:"House Soda",   priceBase:6,  cost:1.0, steps:[["BAR",4],["PASS",1]], baseQuality:0.92, tag:"Drink" },
    { id:"icedtea",  name:"Iced Tea",     priceBase:7,  cost:1.2, steps:[["BAR",5],["PASS",1]], baseQuality:0.92, tag:"Drink" },
    { id:"mocktail", name:"Mocktail",     priceBase:11, cost:2.8, steps:[["BAR",7],["PASS",1]], baseQuality:0.90, tag:"Drink" },
    { id:"coffee",   name:"Coffee",       priceBase:5,  cost:0.9, steps:[["BAR",3],["PASS",1]], baseQuality:0.91, tag:"Drink" },
  ],

inventory:{
  // Prep limits per service. When an item hits 0 it becomes 86'd (stockout).
  base:{ burger:22, pasta:18, salad:26, steak:12, soda:40, icedtea:34, mocktail:22, coffee:30 },
  perExtraCook:{ burger:4, pasta:3, salad:4, steak:2 },
  perExtraBartender:{ soda:10, icedtea:9, mocktail:6, coffee:8 },
  lowThreshold:4
},
  customerTypes: {
    REGULAR: { wRating:1.0, patienceMul:1.05, valueMul:0.95, cleanMul:0.95, picky:0.10, budgetMul:1.00 },
    FAMILY:  { wRating:1.1, patienceMul:0.92, valueMul:1.15, cleanMul:1.00, picky:0.12, budgetMul:0.95 },
    VIP:     { wRating:1.5, patienceMul:0.85, valueMul:1.00, cleanMul:1.15, picky:0.22, budgetMul:1.25 },
    CRITIC:  { wRating:2.6, patienceMul:0.80, valueMul:1.05, cleanMul:1.25, picky:0.35, budgetMul:1.15 },
  },
  names: ["Alex","Sam","Jordan","Taylor","Casey","Riley","Morgan","Jamie","Cameron","Avery","Drew","Kai","Harper","Bailey","Billie","Logan","Quinn","Parker","Reese","Rowan"],
  bookingNames: ["Miller","Nguyen","Singh","Khan","Brown","Taylor","Walker","Jones","Garcia","Wang","Patel","Campbell","Davis","Wilson","Hughes","Martin","Lee","Hall"],
  layout: {
    diningRect: {x:70,y:70,w:620,h:360},
    kitchenRect:{x:70,y:450,w:620,h:180},
    entry:{x:760,y:120},
    host:{x:720,y:160},

    queueStart:{x:760,y:150},
    queueDir:{x:0,y:1},
    queueSpacing:16,
    hostHome:{x:720,y:160},

    passPickup:{x:640,y:520},
    serverHome:{x:720,y:200},
    runnerHome:{x:670,y:560},
    cleanerHome:{x:110,y:610},
    exit:{x:790,y:95},
    tables: [
      {x:140,y:110,seats:2},{x:280,y:110,seats:2},{x:420,y:110,seats:2},
      {x:140,y:250,seats:4},{x:320,y:250,seats:4},
      {x:500,y:250,seats:2},
    ],
    stations: {
      PREP:{x:170,y:525},
      COOK:{x:360,y:525},
      BAR:{x:360,y:590},
      PASS:{x:550,y:525},
    }
  },
  pacing: {
    holdWindow: 28,        // when booking within this many seconds, hold a table
    grace: 12,             // how long after ETA the table can remain held
    estTurnBase: 20,       // base dining duration
    estTurnVar: 8,         // + random variance
    clearBase: 4,          // assumed clear/flip time
  },
  regulars: {
    max: 14,
    returnBase: 0.10,      // baseline returning-regular spawn chance
    returnBoost: 0.22      // + from loyalty
  }
  ,overbooking:{
    // If bookings exceed expected cover capacity, guests will wait longer and bookings may walk out.
    expectedTurnTime: 26,     // avg seconds per table turn (sim time)
    warnRatio: 0.95,          // show warning if bookings > expected*warnRatio
    penaltyBase: 0.06,        // rating penalty when booking walks out
    criticPenaltyMul: 1.7     // critics hit harder
  }

};

/* -------------------- State -------------------- */
const Game = {
  running:false, paused:false,
  speedIdx:0, speedList:[1,2,4],
  day:1, t:0,
  cash:420, rating:3.6, cleanliness:0.92,
  cooks:3, cleaners:0, servers:1, runners:1, bartenders:1,
  skill:{ cook:1.00, bar:1.00 },
  wages:{ cook:120, cleaner:90, server:110, runner:95, bartender:100 },
  acceptWalkins:true,
  prices:{},
  tables:[], guests:[], tickets:[], reviews:[],
  bookings:[],
  inventory:{},
  stations:{},
  complaints:[],
  staff:{ servers:[], runners:[], cleaners:[] },
  host:{ id:'HQ', pos:{x:0,y:0}, state:'IDLE', target:{x:0,y:0}, busyUntil:0, partyId:null },
  overbookLevel:0,

  regularsDB:{}, // customerId -> {name, favDishId, loyalty, visits, lastSat}
  stats:{
    served:0,left:0,revenue:0,costs:0,wages:0,waitTotal:0,waitCount:0,comped:0,
    issues:{slow:0,dirty:0,value:0,foh:0,stockout:0},
    tips:0,
    comps:0,
    refires:0,
    burns:0,
    incidents:0,
    complaintsRaised:0,
    complaintsResolved:0,
    bookings:{total:0,arrived:0,noShow:0,seated:0,left:0}
  },
  spawnAcc:0, reportOpen:false
};

function allMenu(){ return [...DATA.foodMenu, ...DATA.drinkMenu]; }
function getDish(id){ return allMenu().find(d=>d.id===id); }
function isDrink(id){ return !!DATA.drinkMenu.find(d=>d.id===id); }
function isFood(id){ return !!DATA.foodMenu.find(d=>d.id===id); }

function dishStock(id){ return (Game.inventory && (id in Game.inventory)) ? Game.inventory[id] : 999; }
function dishAvailable(id){ return dishStock(id) > 0; }
function initInventory(){
  const inv={};
  const extraCooks = Math.max(0, Game.cooks-3);
  const extraBar   = Math.max(0, Game.bartenders-1);

  for(const d of allMenu()){
    const base = (DATA.inventory.base[d.id] ?? 20);

    let add = 0;
    if(isFood(d.id)){
      const per = (DATA.inventory.perExtraCook[d.id] ?? 3);
      add = extraCooks*per;
    }else{
      const per = (DATA.inventory.perExtraBartender[d.id] ?? 6);
      add = extraBar*per;
    }
    inv[d.id] = Math.round(base + add);
  }
  Game.inventory = inv;
}

function getPrice(id){ const d=getDish(id); return (id in Game.prices) ? Game.prices[id] : d.priceBase; }
function setPrice(id, v){
  const d=getDish(id); if(!d) return;
  const min = Math.max(5, Math.round(d.cost+1));
  Game.prices[id] = U.clamp(Math.round(v), min, 999);
  saveGame();
}
function addRevenue(a){ Game.cash += a; Game.stats.revenue += a; }
function addCost(a){ Game.cash -= a; Game.stats.costs += a; }
function updateRating(d){ Game.rating = U.clamp(Game.rating + d, DATA.ratingFloor, DATA.ratingCeil); }
function foodCostPctToday(){
  const rev=Game.stats.revenue;
  if(rev<=0) return 0;
  return (Game.stats.costs/rev)*100;
}

/* -------------------- Tables & Stations -------------------- */
function initTables(){
  Game.tables = DATA.layout.tables.map((p,i)=>({
    id:"T"+(i+1), x:p.x,y:p.y, seats:p.seats,
    enabled: (Game.build && Array.isArray(Game.build.tableMask)) ? !!Game.build.tableMask[i] : true,
    occupied:0, party:null, dirty:0,
    expectedFreeAt:0,             // pacing: predicted table turnover
    holdForBookingId:null,        // pacing: reserved hold
    holdUntil:0                   // pacing: release time
  }));
}
function clearTable(id){
  const t=Game.tables.find(x=>x.id===id);
  if(t){ t.occupied=0; t.party=null; }
}
function initStations(){
  Game.stations={};
  for(const s of DATA.stations) Game.stations[s]={id:s,queue:[],active:[]};
}
function stationCapacities(){
  // cooks boost PREP/COOK/PASS; bartenders boost BAR
  const caps = { PREP:1, COOK:1, BAR:1, PASS:1 };

  const extraCooks = Math.max(0, Game.cooks-3);
  // spread extra cooks over PREP/COOK/PASS (not BAR)
  const targets = ["COOK","PREP","PASS"];
  for(let i=0;i<extraCooks;i++){
    caps[targets[i%targets.length]] += 1;
  }

  const extraBar = Math.max(0, Game.bartenders-1);
  caps.BAR += extraBar;

  return caps;
}

/* -------------------- Staff pathing -------------------- */
function initStaff(){
  const L=DATA.layout;
  Game.staff.servers = Array.from({length:Game.servers}, (_,i)=>({
    id:"SV"+(i+1), role:"SERVER", pos:{x:L.serverHome.x+U.rand(-6,6), y:L.serverHome.y+U.rand(-6,6)},
    state:"IDLE", target:{x:L.serverHome.x,y:L.serverHome.y}, busyUntil:0, partyId:null, tableId:null
  }));
  Game.staff.runners = Array.from({length:Game.runners}, (_,i)=>({
    id:"RN"+(i+1), role:"RUNNER", pos:{x:L.runnerHome.x+U.rand(-6,6), y:L.runnerHome.y+U.rand(-6,6)},
    state:"IDLE", target:{x:L.runnerHome.x,y:L.runnerHome.y}, busyUntil:0, partyId:null, ticketId:null
  }));
  Game.staff.cleaners = Array.from({length:Game.cleaners}, (_,i)=>({
    id:"CL"+(i+1), role:"CLEANER", pos:{x:L.cleanerHome.x+U.rand(-6,6), y:L.cleanerHome.y+U.rand(-6,6)},
    state:"IDLE", target:{x:L.cleanerHome.x,y:L.cleanerHome.y}, busyUntil:0, tableId:null
  }));


  // host (seats guests)
  Game.host = {
    id:"HQ",
    pos:{x:L.hostHome.x+U.rand(-4,4), y:L.hostHome.y+U.rand(-4,4)},
    state:"IDLE",
    target:{x:L.hostHome.x, y:L.hostHome.y},
    busyUntil:0,
    partyId:null
  };
}
function staffAvailable(list){ return list.find(a=>a.state==="IDLE"); }

/* -------------------- Door queue + Host seating -------------------- */
function queueSpots(){
  const L=DATA.layout;
  const spots=[];
  const base = {x:L.queueStart.x, y:L.queueStart.y};
  for(let i=0;i<18;i++){
    spots.push({x: base.x + L.queueDir.x*i*L.queueSpacing, y: base.y + L.queueDir.y*i*L.queueSpacing});
  }
  return spots;
}

function updateQueueTargets(){
  const spots = queueSpots();
  const queued = Game.guests.filter(g=>g.state==="ARRIVING" || g.state==="QUEUING" || g.state==="WAIT_HOST");
  queued.sort((a,b)=>{
    const ab = a.isBooking?0:1, bb=b.isBooking?0:1;
    if(ab!==bb) return ab-bb;
    return a._arrivedAt - b._arrivedAt;
  });
  for(let i=0;i<queued.length;i++){
    const g = queued[i];
    g.state = "QUEUING";
    const s = spots[Math.min(i, spots.length-1)];
    g.target = {x:s.x, y:s.y};
  }
}

function tableAvailableForParty(party){
  // booking can use held table; walk-in cannot use held table
  if(party.isBooking && party.bookingId){
    const held = Game.tables.find(t=>t.holdForBookingId===party.bookingId && t.occupied===0);
    if(held) return true;
    // allow seating on any free table even if held (booking overrides), but host will prefer held
    return !!bestTableFor(party, true);
  }
  return !!bestTableFor(party, false);
}

function processHost(dt){
  const H = Game.host;
  const L = DATA.layout;

  // host movement
  if(H.state==="MOVING"){
    const at = U.moveTowards(H.pos, H.target, 110, dt);
    if(at){
      H.state="SEATING";
      H.busyUntil = Game.t + U.rand(1.2, 2.6);
    }
    return;
  }
  if(H.state==="SEATING"){
    if(Game.t >= H.busyUntil){
      // seat party now (if still waiting and table exists)
      const p = Game.guests.find(g=>g.id===H.partyId);
      if(p && (p.state==="QUEUING" || p.state==="WAIT_HOST" || p.state==="QUEUING")){
        // attempt seat
        const ok = seatParty(p);
        if(!ok){
          // couldn't seat after all, return and try later
          p.state="WAIT_HOST";
        }
      }
      H.partyId=null;
      H.state="RETURNING";
      H.target={x:L.hostHome.x, y:L.hostHome.y};
    }
    return;
  }
  if(H.state==="RETURNING"){
    const at = U.moveTowards(H.pos, H.target, 110, dt);
    if(at){ H.state="IDLE"; }
    return;
  }

  // IDLE: pick next party from queue (bookings first) that has a table available
  const queued = Game.guests.filter(g=>g.state==="QUEUING" || g.state==="WAIT_HOST");
  if(!queued.length) return;

  queued.sort((a,b)=>{
    const ab = a.isBooking?0:1, bb=b.isBooking?0:1;
    if(ab!==bb) return ab-bb;
    // booking: earlier ETA first; else arrival time
    if(a.isBooking && b.isBooking){
      const ba = Game.bookings.find(x=>x.id===a.bookingId)?.eta ?? a._arrivedAt;
      const bbk = Game.bookings.find(x=>x.id===b.bookingId)?.eta ?? b._arrivedAt;
      return ba-bbk;
    }
    return a._arrivedAt - b._arrivedAt;
  });

  const candidate = queued.find(p=>tableAvailableForParty(p));
  if(!candidate) return;

  // host walks to "host stand" then seats (quick) - we animate a short movement
  H.partyId=candidate.id;
  H.state="MOVING";
  H.target={x:L.host.x+90, y:L.host.y+20};
  candidate.state="WAIT_HOST";
}


/* -------------------- Regulars persistence -------------------- */
function regularsList(){
  const arr = Object.entries(Game.regularsDB).map(([id,v])=>({id,...v}));
  arr.sort((a,b)=> (b.loyalty - a.loyalty) || (b.visits-a.visits));
  return arr;
}
function ensureRegularPool(){
  // Always have a small pool of regulars so the system can't crash.
  Game.regularsDB = Game.regularsDB || {};
  Game.regularOrder = Game.regularOrder || [];

  const firstNames = (DATA.regularFirst && DATA.regularFirst.length) ? DATA.regularFirst
    : ["Sam","Alex","Jordan","Taylor","Casey","Morgan","Riley","Jamie","Avery","Charlie","Jess","Luca","Mia","Noah","Kai"];
  const lastNames  = (DATA.regularLast && DATA.regularLast.length) ? DATA.regularLast
    : ["Ng","Smith","Lee","Brown","Patel","Garcia","Wilson","Johnson","Martin","Walker","Taylor","Harris","Wright","King","Clark"];

  const target = 8;
  while(Game.regularOrder.length < target){
    const id = "R"+U.uid();
    const fn = U.pick(firstNames) || "Guest";
    const ln = U.pick(lastNames) || "";
    const name = (fn + " " + ln).trim();

    const fav = U.pick(DATA.foodMenu || []) || U.pick((DATA.menu||[])) || null;
    const favId = fav ? fav.id : "burger";

    const reg = {
      id,
      name,
      favDishId: favId,
      usualDrinkId: (U.pick(DATA.drinkMenu||[])||{id:"soda"}).id,
      loyalty: U.rand(0.35, 0.75),
      visits: 0,
      lastSeenDay: 0
    };
    Game.regularsDB[id] = reg;
    Game.regularOrder.push(id);
  }
}
function pickReturningRegular(){
  const list = regularsList();
  if(!list.length) return null;
  // weighted by loyalty
  let sum=0;
  for(const r of list){ sum += 0.2 + r.loyalty; }
  let roll=Math.random()*sum;
  for(const r of list){
    roll -= (0.2 + r.loyalty);
    if(roll<=0) return r;
  }
  return list[0];
}
function regularSpawnChance(){
  // more rating -> more regulars, more loyalty in DB -> more returns
  const rn=(Game.rating-DATA.ratingFloor)/(DATA.ratingCeil-DATA.ratingFloor);
  const top = regularsList()[0];
  const topL = top?top.loyalty:0.5;
  return U.clamp(DATA.regulars.returnBase + rn*0.04 + topL*0.10, 0.06, 0.26);
}
function updateRegularAfterVisit(customerId, sat, favDishId){
  const r=Game.regularsDB[customerId];
  if(!r) return;
  r.visits = (r.visits||0)+1;
  r.lastSat = sat;
  // loyalty: good service increases, bad decreases; comped hurts a bit too
  const delta = (sat-0.60)*0.35;
  r.loyalty = U.clamp((r.loyalty||0.5) + delta, 0.05, 0.98);
  // favourite dish sticks, but can change slightly over time if poor sat on fav
  if(favDishId && Math.random()<0.08 && sat>0.75){
    r.favDishId = favDishId;
  }
}

/* -------------------- Guests -------------------- */
function rollCustomerType(){
  const r=Math.random();
  if(r<0.55) return "REGULAR";
  if(r<0.82) return "FAMILY";
  if(r<0.94) return "VIP";
  return "CRITIC";
}
function partySizeForType(type){
  if(type==="FAMILY") return (Math.random()<0.55?4:3);
  return (Math.random()<0.72?2:1);
}
function spawnGuestParty(opts={}){
  // regular memory: some REGULAR spawns become returning regulars
  let type = opts.type || rollCustomerType();
  let customerId = null;
  let customerName = null;
  let returning = false;

  if(type==="REGULAR" && !opts.isBooking){
    const chance = regularSpawnChance();
    if(Math.random() < chance){
      const reg = pickReturningRegular();
      if(reg){
        returning=true;
        customerId = reg.id;
        customerName = reg.name;
      }
    }
  }

  const t = DATA.customerTypes[type];
  const size = opts.size || partySizeForType(type);
  const picky = Math.random() < t.picky;
  const patience = U.rand(35,75)*t.patienceMul*(picky?0.85:1);
  const budget = U.rand(18,55)*t.budgetMul;
  const pref = U.pick(["Fast","Comfort","Light","Premium"]);
  const id="G"+U.uid();
  const pos = {x:DATA.layout.entry.x + U.rand(-6,6), y:DATA.layout.entry.y + U.rand(-6,6)};
  const party={
    id,size,type,picky,patience,budget,pref,
    isBooking:!!opts.isBooking,
    bookingId:opts.bookingId||null,
    customerId, customerName,
    returningRegular:returning,
    state:"ARRIVING",
    pos, target:{x:DATA.layout.host.x, y:DATA.layout.host.y},
    tableId:null, dishId:null,
    seatedAt:null,
    orderedAt:null, serverAt:null,
    ticketId:null,
    foodReadyAt:null, deliveredAt:null,
    servedAt:null,
    satisfaction:1.0,
    note:"",
    _arrivedAt:Game.t,
    _leaveAt:null,
    _reviewed:false,
    _valueFlag:false,
    _dirtyFlag:false,
    _lateFlag:false,
    _comped:false,
  };
  Game.guests.push(party);
  return party;
}

/* -------- Pacing: table availability + holds -------- */
function predictTableFreeAt(table){
  // if occupied, use expectedFreeAt; else now
  const base = table.occupied>0 ? Math.max(Game.t, table.expectedFreeAt) : Game.t;
  // if dirty, add a small flip buffer
  const flip = DATA.pacing.clearBase + table.dirty*4;
  return base + flip;
}

function bestTableFor(party, allowHeld=false){
  // can't use tables held for upcoming booking (unless party is that booking)
  const candidates = Game.tables.filter(t=>{
    if(t.enabled===false) return false;
    if(t.occupied!==0) return false;
    if(!allowHeld && t.holdForBookingId && Game.t < t.holdUntil) return false;
    if(t.seats < party.size) return false;
    return true;
  }).sort((a,b)=>{
    // cleanest and best-fit
    const fitA = a.seats - party.size;
    const fitB = b.seats - party.size;
    if(fitA!==fitB) return fitA-fitB;
    return a.dirty-b.dirty;
  });
  return candidates[0] || null;
}

function holdTablesForUpcomingBookings(){
  const {holdWindow, grace} = DATA.pacing;

  // clear expired holds
  for(const t of Game.tables){
    if(t.holdForBookingId && Game.t >= t.holdUntil){
      t.holdForBookingId=null;
      t.holdUntil=0;
    }
  }

  // for each booking that is near and not resolved, hold a table
  const upcoming = Game.bookings.filter(b=>{
    if(b.status==="NO_SHOW"||b.status==="SEATED"||b.status==="LEFT") return false;
    const dt = b.eta - Game.t;
    return dt <= holdWindow && dt >= -grace;
  });

  for(const b of upcoming){
    // if already has a hold table, keep it
    const held = Game.tables.find(t=>t.holdForBookingId===b.id && Game.t < t.holdUntil);
    if(held) continue;

    // choose best-fit table that will be (likely) free by ETA (or is free now)
    const freeTables = Game.tables.filter(t=>{
      if(t.seats < b.size) return false;
      // don't steal another booking's hold
      if(t.holdForBookingId && Game.t < t.holdUntil) return false;
      // if occupied, check predicted free before eta+grace
      const freeAt = predictTableFreeAt(t);
      return freeAt <= (b.eta + grace);
    }).sort((a,b2)=>{
      const fa = predictTableFreeAt(a);
      const fb = predictTableFreeAt(b2);
      // prefer tables that are free sooner, then best fit
      if(fa!==fb) return fa-fb;
      const fitA = a.seats - b.size;
      const fitB = b2.seats - b.size;
      if(fitA!==fitB) return fitA-fitB;
      return a.dirty - b2.dirty;
    });

    const pick = freeTables[0];
    if(pick){
      pick.holdForBookingId = b.id;
      pick.holdUntil = Math.max(Game.t + 6, b.eta + grace);
    }
  }
}

/* -------- seating -------- */
function seatParty(p){
  // if booking and a table is held for it, prefer that
  let t = null;
  if(p.isBooking && p.bookingId){
    t = Game.tables.find(x=>x.enabled!==false && x.holdForBookingId===p.bookingId && x.occupied===0);
    if(!t){
      // try any table even if held (because booking)
      t = bestTableFor(p, true);
    }
  }else{
    t = bestTableFor(p, false);
  }

  if(!t) return false;

  // occupy and clear hold if it was held for this booking
  t.occupied=p.size; t.party=p.id;
  if(p.isBooking && p.bookingId && t.holdForBookingId===p.bookingId){
    t.holdForBookingId=null; t.holdUntil=0;
  }

  // predict turnover time once seated
  const dine = DATA.pacing.estTurnBase + U.rand(-DATA.pacing.estTurnVar, DATA.pacing.estTurnVar) + (p.size>=4?3:0) + (p.type==="VIP"||p.type==="CRITIC"?2:0);
  t.expectedFreeAt = Game.t + Math.max(10, dine);

  p.tableId=t.id;
  p.state="WALK_TO_TABLE";
  p.seatedAt=Game.t;
  p.target = {x: t.x + 62, y: t.y + 34};

  if(t.dirty>0.25){
    p._dirtyFlag=true;
    p.note = p.note || "Table was dirty";
  }

  if(p.isBooking && p.bookingId){
    const b = Game.bookings.find(x=>x.id===p.bookingId);
    if(b && b.status!=="SEATED"){ b.status="SEATED"; b.partyId=p.id; Game.stats.bookings.seated += 1; }
  }
  return true;
}

/* -------------------- Dish selection (incl regular favourites) -------------------- */
function chooseDish(p){
  // Choose a food dish for the party. Must always return a valid dish object.
  const full = (DATA.foodMenu && DATA.foodMenu.length) ? DATA.foodMenu : (DATA.menu || []);
  if(!full.length){
    // absolute fallback (should never happen)
    return { id:"burger", name:"Burger & Chips", priceBase:24, cost:8.5, steps:[["PREP",5],["COOK",10],["PASS",3]], baseQuality:0.86, tag:"Fast" };
  }

  // Build an available pool (in-stock). If everything is 86'd, fall back to full menu.
  let pool = full.filter(d=>dishAvailable(d.id));
  if(!pool.length) pool = full;

  // Regulars bias to their favourite if possible
  if(p && p.customerId && p.returningRegular && Game.regularsDB && Game.regularsDB[p.customerId]){
    const favId = Game.regularsDB[p.customerId].favDishId;
    const fav = getDish(favId);
    if(fav && (dishAvailable(fav.id) || Math.random()<0.25)) return fav;
  }

  // Value-sensitive guests avoid expensive dishes when value flag is set
  if(p && p._valueFlag){
    const cheaper = pool.filter(d=>getPrice(d.id) <= (p.budget ?? 999));
    if(cheaper.length) pool = cheaper;
  }

  return U.pick(pool) || pool[0] || full[0];
}

/* -------------------- Bookings -------------------- */
function buildBookingsForDay(){
  const total = 10 + Math.floor(Math.random()*5); // 10‚Äì14
  const shift = DATA.shiftSeconds;
  const list = [];
  const peakA = 48 + Math.random()*18;
  const peakB = 118 + Math.random()*22;

  for(let i=0;i<total;i++){
    let eta;
    const r=Math.random();
    if(r<0.20) eta = U.rand(10, 40);
    else if(r<0.62) eta = U.clamp(peakA + (Math.random()-0.5)*40, 12, shift-15);
    else eta = U.clamp(peakB + (Math.random()-0.5)*45, 12, shift-15);

    eta = Math.round(eta);
    const type = (Math.random()<0.10) ? "VIP" : (Math.random()<0.08 ? "CRITIC" : (Math.random()<0.38 ? "FAMILY" : "REGULAR"));
    const size = (type==="FAMILY") ? (Math.random()<0.55?4:3) : (Math.random()<0.8?2:1);
    const noShowProb = (type==="VIP"||type==="CRITIC") ? 0.06 : 0.12;
    const name = U.pick(DATA.bookingNames);
    list.push({
      id:"B"+U.uid(),
      eta,
      name,
      type,
      size,
      noShowProb,
      status:"SCHEDULED",
      partyId:null
    });
  }
  
  list.sort((a,b)=>a.eta-b.eta);
  Game.bookings = list;
  Game.stats.bookings.total = list.length;

  // Overbooking model: compare bookings to expected covers capacity for the shift
  const totalSeats = Game.tables.reduce((s,t)=>s+t.seats,0);
  const expectedTurns = DATA.shiftSeconds / DATA.overbooking.expectedTurnTime;
  const expectedCovers = totalSeats * expectedTurns * 0.78; // assume imperfect fill
  Game.overbookLevel = Math.max(0, (list.length*2.6 - expectedCovers) / Math.max(1, expectedCovers)); // heuristic
}

function processBookings(){
  for(const b of Game.bookings){
    if(b.status!=="SCHEDULED") continue;
    if(Game.t < b.eta) continue;

    if(Math.random() < b.noShowProb){
      b.status="NO_SHOW";
      Game.stats.bookings.noShow += 1;
      continue;
    }

    b.status="ARRIVED";
    Game.stats.bookings.arrived += 1;
    spawnGuestParty({type:b.type, size:b.size, isBooking:true, bookingId:b.id});
  }
}

/* -------------------- Tickets / Kitchen -------------------- */
function ticketQualityEstimate(t){
  const wait = Game.t - t.orderedAt;
  const waitFactor = U.clamp(1 - (wait-22)/85, 0.22, 1.0);
  const cleanFactor = U.clamp(0.7 + Game.cleanliness*0.4, 0.7, 1.1);

  const skill = (t.kind==="DRINK") ? Game.skill.bar : Game.skill.cook;

  // If a station is backed up, quality slips slightly (rushed/held)
  let backlog = 0;
  for(const sid of DATA.stations){
    backlog += (Game.stations[sid]?.queue?.length || 0);
  }
  const backlogFactor = U.clamp(1 - backlog/220, 0.88, 1.0);

  return U.clamp(t.baseQuality*waitFactor*cleanFactor*skill*backlogFactor, 0.2, 1.0);
}
function valueModifier(dishId, quality, party){
  const d=getDish(dishId);
  const price=getPrice(dishId);
  const rn=(Game.rating-DATA.ratingFloor)/(DATA.ratingCeil-DATA.ratingFloor);
  const expected = d.priceBase*(0.92+rn*0.18);
  const pressure = price/expected;
  const qualityOffset = U.clamp((quality-0.78)*1.1, -0.1, 0.15);
  const effective = pressure - qualityOffset;

  const typeT = DATA.customerTypes[party.type] || DATA.customerTypes.REGULAR;
  let mult=1, flag=false;

  if(effective>1.15){
    mult*= (1-U.clamp((effective-1.15)*0.35*typeT.valueMul,0,0.30));
    flag=true;
  }else if(effective<0.88){
    mult*=(1+U.clamp((0.88-effective)*0.18,0,0.10));
  }
  if(price>party.budget){ mult*=0.94; if(effective>1.10) flag=true; }
  return {mult, flag};
}

function createTicketForParty(party, dish){
  // Stockouts: if dish not available, pick another and record issue
  let chosen = dish;
  if(!dishAvailable(dish.id)){
    Game.stats.issues.stockout += 1;
    party._stockoutFlag = true;
    party.note = party.note || "Dish was sold out";
    const alt = chooseDish(party);
    chosen = alt || dish;
  }

  const qty = Math.max(1, party.size);

  // decrement stock per head
  if(chosen && chosen.id){
    Game.inventory[chosen.id] = Math.max(0, dishStock(chosen.id) - qty);
    if(Game.inventory[chosen.id]===0){
      toast(chosen.name + " is now 86'd!");
    }
  }

  const unitPrice = getPrice(chosen.id);
  const totalPrice = unitPrice * qty;
  const totalCost  = chosen.cost * qty;

  addCost(totalCost);

  const t={
    kind:"FOOD",
    id:"K"+U.uid(),
    partyId:party.id,
    dishId:chosen.id,
    dishName:chosen.name,
    qty,
    unitPrice,
    price:totalPrice,
    cost:totalCost,
    baseQuality:chosen.baseQuality,
    steps:chosen.steps.map(([station,time])=>({station,time,remaining:time,state:"QUEUED"})),
    stepIndex:0,
    orderedAt:Game.t,
    status:"QUEUED"
  };
  Game.tickets.push(t);
  enqueueNextStep(t);
  party.ticketId = t.id;
  party.billAmount = (party.billAmount||0) + totalPrice;
  party._paid = false;
}

function chooseDrink(p){
  // some guests skip drinks; VIP/critics more likely; families moderate; regulars based on value
  const base = (p.type==="VIP"||p.type==="CRITIC") ? 0.78 : (p.type==="FAMILY" ? 0.52 : 0.48);
  const valuePressure = p._valueFlag ? -0.12 : 0;
  const chance = U.clamp(base + valuePressure + (Game.rating-3.5)*0.06, 0.20, 0.90);
  if(Math.random() > chance) return null;

  // returning regulars sometimes have a usual drink (light memory)
  if(p.customerId && p.returningRegular && Math.random()<0.35){
    const reg = Game.regularsDB[p.customerId];
    if(reg && reg.usualDrinkId && dishAvailable(reg.usualDrinkId)){
      return getDish(reg.usualDrinkId);
    }
  }

  const pool = DATA.drinkMenu.filter(d=>dishAvailable(d.id));
  if(!pool.length) return null;
  return U.pick(pool);
}

function createDrinkTicket(party, drink){
  if(!drink) return;
  let chosen = drink;
  if(!dishAvailable(drink.id)){
    Game.stats.issues.stockout += 1;
    party._stockoutFlag = true;
    party.note = party.note || "Drink was sold out";
    const alt = DATA.drinkMenu.filter(d=>dishAvailable(d.id))[0];
    chosen = alt || drink;
  }

  const qty = Math.max(1, party.size>=3 ? Math.round(party.size*0.65) : 1); // not everyone orders
  Game.inventory[chosen.id] = Math.max(0, dishStock(chosen.id) - qty);
  if(Game.inventory[chosen.id]===0) toast(chosen.name + " is now 86'd!");

  const unitPrice = getPrice(chosen.id);
  const totalPrice = unitPrice * qty;
  const totalCost  = chosen.cost * qty;

  addCost(totalCost);

  const t={
    id:"D"+U.uid(),
    kind:"DRINK",
    partyId:party.id,
    dishId:chosen.id,
    dishName:chosen.name,
    qty,
    unitPrice,
    price:totalPrice,
    cost:totalCost,
    baseQuality:chosen.baseQuality,
    steps:chosen.steps.map(([station,time])=>({station,time,remaining:time,state:"QUEUED"})),
    stepIndex:0,
    orderedAt:Game.t,
    status:"QUEUED"
  };
  Game.tickets.push(t);
  enqueueNextStep(t);

  party.billAmount = (party.billAmount||0) + totalPrice;
  party._drinkTicketId = t.id;
}

function enqueueNextStep(t){
  const idx=t.stepIndex;
  if(idx>=t.steps.length){ t.status="READY"; t.finishedAt=Game.t; applyIncidentOnReady(t); return; }
  const step=t.steps[idx];
  step.state="QUEUED";
  Game.stations[step.station].queue.push({ticketId:t.id, stepIndex:idx});
  t.status="COOKING";
}

function incidentChance(t){
  // Incidents increase with low cleanliness, high backlog, and lower skill.
  let backlog = 0;
  for(const sid of DATA.stations){
    backlog += (Game.stations[sid]?.queue?.length || 0) + (Game.stations[sid]?.active?.length || 0);
  }
  const cleanBad = U.clamp((0.78 - Game.cleanliness), 0, 0.6);
  const skill = (t.kind==="DRINK") ? Game.skill.bar : Game.skill.cook;
  const skillBad = U.clamp(1.05 - skill, 0, 0.35);

  let base = (t.kind==="DRINK") ? 0.025 : 0.045;
  base += cleanBad*0.08;
  base += U.clamp(backlog/140, 0, 0.45)*0.06;
  base += skillBad*0.10;

  return U.clamp(base, 0.01, 0.14);
}

function applyIncidentOnReady(t){
  if(t._incidentOnce) return;
  const p = Game.guests.find(g=>g.id===t.partyId);
  if(!p) return;

  const ch = incidentChance(t);
  if(Math.random() > ch) return;

  t._incidentOnce = true;
  Game.stats.incidents += 1;

  // choose incident type
  const r = Math.random();
  if(r < 0.42){
    // REFIRE: remake item -> extra time + waste cost
    Game.stats.refires += 1;
    p._refireFlag = true;
    p.note = p.note || "Refire in the kitchen";

    // waste cost (remake)
    addCost(t.cost * 0.35);

    // reset steps (refire only 1 station + pass)
    const main = (t.kind==="DRINK") ? "BAR" : "COOK";
    const extraTime = (t.kind==="DRINK") ? U.rand(3,6) : U.rand(6,11);
    t.steps = [
      {station:main, time:extraTime, remaining:extraTime, state:"QUEUED"},
      {station:"PASS", time:U.rand(1,3), remaining:U.rand(1,3), state:"QUEUED"}
    ];
    t.stepIndex = 0;
    t.status = "COOKING";
    t.finishedAt = null;
    t._delivered = false;

    toast("üî• Refire: " + t.dishName);
    enqueueNextStep(t);
    return;
  }else if(r < 0.70){
    // BURN/RUSH: quality drops
    Game.stats.burns += 1;
    p._burnFlag = true;
    t.baseQuality = U.clamp(t.baseQuality * U.rand(0.78, 0.90), 0.2, 1.0);
    p.note = p.note || "Kitchen was rushed";
    toast("‚ö†Ô∏è Quality slip: " + t.dishName);
    return;
  }else{
    // COMP: discount item (hits margin at payment)
    const compAmt = t.price * U.rand(0.25, 0.60);
    p.compAmount = (p.compAmount||0) + compAmt;
    p._compFlag = true;
    Game.stats.comps += compAmt;
    p.note = p.note || "Comped item (service recovery)";
    toast("üí∏ Comp: $" + Math.round(compAmt));
    return;
  }
}
function processStations(dt){
  const caps = stationCapacities();

  for(const sid of DATA.stations){
    const st=Game.stations[sid];

    while(st.active.length < (caps[sid]||1) && st.queue.length){
      const task=st.queue.shift();
      st.active.push(task);
      const t=Game.tickets.find(x=>x.id===task.ticketId);
      if(t) t.steps[task.stepIndex].state="ACTIVE";
    }

    for(let i=st.active.length-1;i>=0;i--){
      const a=st.active[i];
      const t=Game.tickets.find(x=>x.id===a.ticketId); if(!t){ st.active.splice(i,1); continue; }
      const step=t.steps[a.stepIndex]; if(!step){ st.active.splice(i,1); continue; }

      const cleanFactor = U.clamp(1.0+(Game.cleanliness-0.85)*0.6, 0.72, 1.15);
      const skillFactor = (sid==="BAR") ? Game.skill.bar : Game.skill.cook;
      const up = (Game.build||{});
      const upgradeFactor = (sid==="BAR") ? (1 + 0.05*(up.barLevel||0)) : (1 + 0.05*(up.kitchenLevel||0));

      // Bottlenecks: if station queue is huge, stress slows a bit
      const pressure = U.clamp(1 - (st.queue.length/24)*0.12, 0.86, 1.0);

      step.remaining -= dt * cleanFactor * skillFactor * upgradeFactor * pressure;

      if(step.remaining<=0){
        step.state="DONE";
        st.active.splice(i,1);
        t.stepIndex += 1;
        enqueueNextStep(t);
      }
    }
  }
}

/* -------------------- Cleaning -------------------- */
function scheduleClear(table){
  table.dirty = U.clamp(table.dirty + U.rand(0.25, 0.45), 0, 1);
}
function processCleaning(dt){
  const passive = 0.015*dt;
  for(const t of Game.tables){ t.dirty = U.clamp(t.dirty - passive, 0, 1); }

  for(const cl of Game.staff.cleaners){
    if(cl.state==="MOVING"){
      const at = U.moveTowards(cl.pos, cl.target, 92, dt);
      if(at){
        cl.state = "CLEANING";
        cl._doneAt = Game.t + U.rand(3.5, 6.5);
      }
    }else if(cl.state==="CLEANING"){
      const tid = cl.tableId;
      const t = Game.tables.find(x=>x.id===tid);
      if(t) t.dirty = U.clamp(t.dirty - 0.11*dt, 0, 1);
      if(Game.t >= cl._doneAt){
        if(t) t.dirty = U.clamp(t.dirty - 0.25, 0, 1);
        cl.state="RETURNING";
        cl.target = {x:DATA.layout.cleanerHome.x, y:DATA.layout.cleanerHome.y};
        cl.tableId=null;
      }
    }else if(cl.state==="RETURNING"){
      const at = U.moveTowards(cl.pos, cl.target, 92, dt);
      if(at){ cl.state="IDLE"; }
    }else if(cl.state==="IDLE"){
      const target = Game.tables.filter(t=>t.occupied===0 && t.dirty>0.18).sort((a,b)=>b.dirty-a.dirty)[0];
      if(target){
        cl.tableId = target.id;
        cl.state="MOVING";
        cl.target = {x:target.x+62, y:target.y+34};
      }
    }
  }
}

/* -------------------- Runner deliveries -------------------- */
function processRunnerDeliveries(dt){
const ready = Game.tickets.filter(t=>t.status==="READY" && !t._delivered);
// runner prioritises drinks first to keep mood up
ready.sort((a,b)=>{
  const ak = a.kind==="DRINK" ? 0 : 1;
  const bk = b.kind==="DRINK" ? 0 : 1;
  if(ak!==bk) return ak-bk;
  return (a.finishedAt??0) - (b.finishedAt??0);
});
  for(const t of ready){
    const party = Game.guests.find(g=>g.id===t.partyId);
    if(!party || party.state==="DONE") continue;

    const runner = staffAvailable(Game.staff.runners);
    if(!runner) { Game.stats.issues.foh += dt*0.2; continue; }

    runner.state="TO_PICKUP";
    runner.ticketId=t.id;
    runner.partyId=party.id;
    runner.target={x:DATA.layout.passPickup.x, y:DATA.layout.passPickup.y};

    t._delivered = true;
    if(t.kind==="DRINK") party.drinkReadyAt = party.drinkReadyAt ?? Game.t;
    else party.foodReadyAt = party.foodReadyAt ?? Game.t;
  }

  for(const r of Game.staff.runners){
    if(r.state==="TO_PICKUP"){
      const at=U.moveTowards(r.pos, r.target, 104, dt);
      if(at){
        r.state="TO_TABLE";
        const party = Game.guests.find(g=>g.id===r.partyId);
        if(party && party.tableId){
          const table = Game.tables.find(t=>t.id===party.tableId);
          r.target = table ? {x:table.x+62, y:table.y+34} : {x:DATA.layout.host.x, y:DATA.layout.host.y};
        }else{
          r.target = {x:DATA.layout.host.x, y:DATA.layout.host.y};
        }
      }
    }else if(r.state==="TO_TABLE"){
      const at=U.moveTowards(r.pos, r.target, 104, dt);
      if(at){
        r.state="DELIVERING";
        r._deliverDoneAt = Game.t + U.rand(1.0, 2.2);
      }
    }else if(r.state==="DELIVERING"){
      if(Game.t >= r._deliverDoneAt){
        const party = Game.guests.find(g=>g.id===r.partyId);
        if(party && (party.state==="WAIT_FOOD" || party.state==="EATING" || party.state==="READY_TO_PAY")){
          const tick = Game.tickets.find(t=>t.id===r.ticketId);
          if(tick && tick.kind==="DRINK"){
party._hadDrink = true;
party._drinkDeliveredAt = Game.t;
const sinceSeat = party.seatedAt ? (party._drinkDeliveredAt - party.seatedAt) : 999;
if(sinceSeat <= 9){
  party._drinkFast = true;
  party.satisfaction = U.clamp((party.satisfaction ?? 0.62) + 0.07, 0.1, 1.0);
}else if(sinceSeat >= 18){
  party._drinkSlow = true;
  party.satisfaction = U.clamp((party.satisfaction ?? 0.62) - 0.03, 0.1, 1.0);
  party.note = party.note || "Drinks were late";
  Game.stats.issues.foh += 0.5;
}else{
  party.satisfaction = U.clamp((party.satisfaction ?? 0.62) + 0.03, 0.1, 1.0);
}
          }else{
            party.deliveredAt = Game.t;
            party._deliverTicketId = r.ticketId;
          }
        }
        r.state="RETURNING";
        r.target={x:DATA.layout.runnerHome.x, y:DATA.layout.runnerHome.y};
      }
    }else if(r.state==="RETURNING"){
      const at=U.moveTowards(r.pos, r.target, 104, dt);
      if(at){
        r.state="IDLE";
        r.ticketId=null; r.partyId=null;
      }
    }
  }
}

/* -------------------- Server takes orders -------------------- */
function processServers(dt){
  for(const sv of Game.staff.servers){
    if(sv.state==="TO_TABLE"){
      const at=U.moveTowards(sv.pos, sv.target, 96, dt);
      if(at){
        sv.state="TAKING_ORDER";
        sv._doneAt = Game.t + U.rand(2.0, 5.0);
      }
    }else if(sv.state==="TAKING_ORDER"){
      if(Game.t >= sv._doneAt){
        const party = Game.guests.find(g=>g.id===sv.partyId);
        if(party && (party.state==="SEATED_WAIT_SERVER" || party.state==="ORDER_BEING_TAKEN")){
          party.serverAt = Game.t;
          const dish=chooseDish(party);
          party.dishId=dish.id;
          party.orderedAt=Game.t;
          party.state="WAIT_FOOD";
          createTicketForParty(party, dish);
          const dr = chooseDrink(party);
          if(dr) createDrinkTicket(party, dr);
        }
        sv.state="RETURNING";
        sv.target={x:DATA.layout.serverHome.x, y:DATA.layout.serverHome.y};
        sv.partyId=null; sv.tableId=null;
      }
    }else if(sv.state==="TO_TABLE_PAY"){
      const at=U.moveTowards(sv.pos, sv.target, 96, dt);
      if(at){
sv.state="TAKING_PAYMENT";
const party = Game.guests.find(g=>g.id===sv.partyId);

// split bills: more likely with bigger groups; VIP/critic less likely
let splits = 1;
if(party){
  const base = (party.type==="VIP"||party.type==="CRITIC") ? 0.18 : 0.32;
  const chance = U.clamp(base + (party.size-2)*0.10, 0.0, 0.75);
  if(Math.random() < chance){
    splits = (party.size>=5) ? U.pick([2,3]) : 2;
  }
  party._splitCount = splits;
}

// EFTPOS delays: occasional terminal issue, worse when busy
let backlog=0; for(const sid of DATA.stations){ backlog += (Game.stations[sid]?.queue?.length||0); }
const eftpos = (Math.random() < U.clamp(0.06 + backlog/260*0.05, 0.06, 0.16)) ? U.rand(2.0, 6.0) : 0;
if(party && eftpos>0){ party._eftposFlag = true; party.note = party.note || "EFTPOS took ages"; }

sv._eftposDelay = eftpos;
sv._splits = splits;
sv._doneAt = Game.t + U.rand(1.6, 3.6) + (splits-1)*1.25 + eftpos;
      }
    }else if(sv.state==="TAKING_PAYMENT"){
      if(Game.t >= sv._doneAt){
        const party = Game.guests.find(g=>g.id===sv.partyId);
        if(party && party.state==="READY_TO_PAY" && !party._paid){
const subtotal = Math.max(0, (party.billAmount ?? 0) - (party.compAmount ?? 0));
// tip based on satisfaction + guest type
const sat = party.satisfaction ?? 0.6;
const base = (party.type==="VIP"||party.type==="CRITIC") ? 0.10 : (party.type==="FAMILY" ? 0.07 : 0.08);
let tipPct = base + (sat-0.65)*0.18;
if(party._lateFlag) tipPct -= 0.03;
if(party._dirtyFlag) tipPct -= 0.03;
if(party._drinkSlow) tipPct -= 0.02;
tipPct = U.clamp(tipPct, 0.0, 0.22);
const tip = (sat>0.45) ? (subtotal * tipPct) : 0;

if(subtotal>0) addRevenue(subtotal + tip);
Game.stats.tips += tip;

if((party.compAmount ?? 0) > 0){
  // comps count already tracked; this just records per-party
}
          party._paid = true;

          // clear & dirty table now that they pay and stand up
          if(party.tableId){
            const t = Game.tables.find(x=>x.id===party.tableId);
            if(t){
              scheduleClear(t);
              t.expectedFreeAt = Game.t + DATA.pacing.clearBase + t.dirty*2;
            }
            clearTable(party.tableId);
          }

          party.state="LEAVING";
          party.target={x:DATA.layout.exit.x, y:DATA.layout.exit.y};
        }
        sv.state="RETURNING";
        sv.target={x:DATA.layout.serverHome.x, y:DATA.layout.serverHome.y};
        sv.partyId=null; sv.tableId=null;
      }
    }else if(sv.state==="RETURNING"){
      const at=U.moveTowards(sv.pos, sv.target, 96, dt);
      if(at){ sv.state="IDLE"; }
    }else if(sv.state==="IDLE"){
      // PRIORITY 1: take payments (freeing tables)
      const pay = Game.guests.filter(g=>g.state==="READY_TO_PAY" && !g._paid);
      if(pay.length){
        pay.sort((a,b)=>{
          const pa = (a.type==="CRITIC"||a.type==="VIP")?0:1;
          const pb = (b.type==="CRITIC"||b.type==="VIP")?0:1;
          if(pa!==pb) return pa-pb;
          return (a._payRequestedAt??0)-(b._payRequestedAt??0);
        });
        const p = pay[0];
        sv.partyId=p.id;
        sv.tableId=p.tableId;
        const table = Game.tables.find(t=>t.id===p.tableId);
        sv.target = table ? {x:table.x+62, y:table.y+34} : {x:DATA.layout.host.x, y:DATA.layout.host.y};
        sv.state="TO_TABLE_PAY";
        continue;
      }

      // PRIORITY 2: take orders
      const candidates = Game.guests.filter(g=>g.state==="SEATED_WAIT_SERVER");
      if(candidates.length){
        candidates.sort((a,b)=>{
          const ab = a.isBooking?0:1, bb=b.isBooking?0:1;
          if(ab!==bb) return ab-bb;
          return (a.seatedAt??0)-(b.seatedAt??0);
        });
        const p=candidates[0];
        sv.partyId=p.id;
        sv.tableId=p.tableId;
        const table = Game.tables.find(t=>t.id===p.tableId);
        sv.target = table ? {x:table.x+62, y:table.y+34} : {x:DATA.layout.host.x, y:DATA.layout.host.y};
        sv.state="TO_TABLE";
        p.state="ORDER_BEING_TAKEN";
      }
    }
  }
}

/* -------------------- Satisfaction & review -------------------- */
function finalizeDeliveredParty(party, ticket){
  const typeT = DATA.customerTypes[party.type] || DATA.customerTypes.REGULAR;

  const kitchenQ = ticketQualityEstimate(ticket);
  const passDelay = (party.deliveredAt && party.foodReadyAt) ? Math.max(0, party.deliveredAt - party.foodReadyAt) : 0;
  const passFactor = U.clamp(1 - (passDelay-2.0)/10.0, 0.55, 1.0);
  const q = U.clamp(kitchenQ * passFactor, 0.2, 1.0);

  const orderWait = (party.serverAt && party.seatedAt) ? (party.serverAt - party.seatedAt) : 0;
  const foodWait = (party.orderedAt && party.deliveredAt) ? (party.deliveredAt - party.orderedAt) : 0;

  let sat = q;
// drink timing
if(party._hadDrink){
  const dT = (party._drinkDeliveredAt && party.seatedAt) ? (party._drinkDeliveredAt - party.seatedAt) : 999;
  if(dT <= 9) sat *= 1.06;
  else if(dT >= 18) sat *= 0.93;
  else sat *= 1.02;
  // if drinks arrived after food was already delivered -> small penalty
  if(party.deliveredAt && party._drinkDeliveredAt && party._drinkDeliveredAt > party.deliveredAt + 2){
    sat *= 0.97;
    party._drinkAfterFood = true;
  }
}

  const late = foodWait > party.patience;
  if(late){ sat *= 0.55; Game.stats.issues.slow += 1; party._lateFlag=true; party.note = party.note || "Waited too long"; }

  if(orderWait > 10){
    sat *= U.clamp(1 - (orderWait-10)/40, 0.75, 1.0);
    if(orderWait>22){ party.note = party.note || "Hard to get attention"; Game.stats.issues.foh += 1; }
  }

  const table = party.tableId ? Game.tables.find(t=>t.id===party.tableId) : null;
  const tableDirt = table ? table.dirty : 0;
  if(Game.cleanliness < 0.6 || tableDirt>0.25){
    const dirtyPenalty = U.clamp(0.95 - (0.6-Game.cleanliness)*0.4*typeT.cleanMul, 0.70, 1.0);
    sat *= dirtyPenalty;
    party._dirtyFlag = true;
    if(Game.cleanliness<0.55) Game.stats.issues.dirty += 1;
    party.note = party.note || "Cleanliness could improve";
  }

  const v = valueModifier(ticket.dishId, q, party);
  sat *= v.mult;
  party._valueFlag = party._valueFlag || v.flag;
  if(v.flag){ Game.stats.issues.value += 1; party.note = party.note || "Value felt off"; }

  if(party.picky){ sat *= U.clamp(0.9 + (q-0.75)*0.6, 0.55, 1.1); }

const refund = sat < 0.33;
party._comped = refund;
if(refund){
  const compAmt = (party.billAmount||0) * U.rand(0.20, 0.45);
  party.compAmount = (party.compAmount||0) + compAmt;
  party._compFlag = true;
  Game.stats.comps += compAmt;
  party.note = party.note || "Service recovery comp";
}
  if(refund){ Game.stats.comped += 1; updateRating(-0.10*typeT.wRating); }
  else { updateRating(+0.02*typeT.wRating); }

  party.satisfaction = U.clamp(sat,0.1,1.0);
  party.servedAt = Game.t;
  party.state = "EATING";
  party._leaveAt = Game.t + U.rand(10, 20);

  // update regular memory
  if(party.customerId){
    updateRegularAfterVisit(party.customerId, party.satisfaction, ticket.dishId);
  }

  if(Math.random() < DATA.litterChance) Game.cleanliness = U.clamp(Game.cleanliness-0.06,0,1);

  Game.stats.served += party.size;
  Game.stats.waitTotal += foodWait;
  Game.stats.waitCount += 1;
}

function starsFromSat(sat){
  const s = Math.round(U.clamp(1 + sat*4.2, 1, 5));
  return U.clamp(s,1,5);
}
function starsToText(stars){
  return "‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ".slice(0,stars) + "‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ".slice(0,5-stars);
}
function makeReview(p){
  const decorBonus = 0.02 * ((Game.build||{}).decorLevel||0);
  const sat = U.clamp((p.satisfaction ?? 0.6) + decorBonus, 0.1, 1.0);
  const stars = starsFromSat(sat);
  const dish = p.dishId ? getDish(p.dishId) : null;
  const dishName = dish ? dish.name : "Food";
  const typeT = DATA.customerTypes[p.type] || DATA.customerTypes.REGULAR;

  const tags = [p.type];
  if(p.isBooking) tags.push("BOOKING");
  if(p.returningRegular) tags.push("REGULAR‚ù§");
  if(p._comped) tags.push("COMPED");
  if(p._valueFlag) tags.push("VALUE");
  if(p._stockoutFlag) tags.push("86");
  if(p._hadDrink) tags.push("DRINK");
  if(p._drinkFast) tags.push("FASTDR");
  if(p._drinkSlow) tags.push("SLOWDR");
  if(p._refireFlag) tags.push("REFIRE");
  if(p._compFlag) tags.push("COMP");
  if(p._burnFlag) tags.push("RUSH");
  if(p._dirtyFlag) tags.push("CLEAN");
  if(p._lateFlag) tags.push("WAIT");
  if(p.type==="CRITIC") tags.push("IMPACT");

  const critic = [
    "Execution needs tightening ‚Äî timing and heat control were off.",
    "Strong intent, but service flow didn't match the pricing.",
    "Great fundamentals. Needs more consistency to be special.",
    "You can feel the potential here ‚Äî fix the pacing and it sings."
  ];
  const vip = [
    "Loved the idea, but the detail has to be sharper at this price point.",
    "Staff were friendly, but I noticed the wait.",
    "Pretty good ‚Äî just missing that polish."
  ];
  const family = [
    "Kids were hungry ‚Äî service was slow.",
    "Good feed, fair price. Easy option for families.",
    "Table needed a wipe, but food hit the spot."
  ];
  const regular = [
    "Solid local spot. I'll come back.",
    "Good value and quick enough.",
    "Bit messy today, but still decent."
  ];

  const name = p.customerName || U.pick(DATA.names);
  let line = "";
  if(p.type==="CRITIC") line = U.pick(critic);
  else if(p.type==="VIP") line = U.pick(vip);
  else if(p.type==="FAMILY") line = U.pick(family);
  else line = U.pick(regular);

  if(p.returningRegular && p.customerId){
    const reg = Game.regularsDB[p.customerId];
    if(reg){
      const fav = getDish(reg.favDishId)?.name || "their usual";
      line = `I'm a regular ‚Äî came in for ${fav}. ` + line;
    }
  }

  if(p._comped) line = "They comped the meal after issues ‚Äî appreciated, but it was chaotic.";
  else{
    if(p._lateFlag) line += " Wait time needs work.";
    if(p._valueFlag) line += " Value felt off.";
    if(p._dirtyFlag) line += " Cleanliness could be better.";
  }

  const impact = (p.type==="CRITIC") ? 1.0 : (p.type==="VIP" ? 0.5 : 0.2);
  updateRating((stars-3)*0.008*typeT.wRating*impact);

  const review = {
    id:"R"+U.uid(),
    t:Game.t,
    name,
    type:p.type,
    stars,
    starsText:starsToText(stars),
    dish:dishName,
    text:line,
    tags,
    sat
  };
  Game.reviews.unshift(review);
  if(Game.reviews.length > 50) Game.reviews.pop();
}

/* -------------------- Day flow -------------------- */
function applyDailyWages(){
  const wages = Game.cooks*Game.wages.cook + Game.cleaners*Game.wages.cleaner + Game.servers*Game.wages.server + Game.runners*Game.wages.runner + Game.bartenders*Game.wages.bartender;
  Game.cash -= wages;
  Game.stats.wages = wages;
}
function startDay(){
  Game.running=true; Game.paused=false; Game.reportOpen=false;
  Game.t=0; Game.spawnAcc=0;
  Game.guests=[]; Game.tickets=[];
  Game.stats={
    served:0,left:0,revenue:0,costs:0,wages:0,waitTotal:0,waitCount:0,comped:0,
    issues:{slow:0,dirty:0,value:0,foh:0,stockout:0},
    tips:0,
    comps:0,
    refires:0,
    burns:0,
    incidents:0,
    complaintsRaised:0,
    complaintsResolved:0,
    bookings:{total:0,arrived:0,noShow:0,seated:0,left:0}
  };
  initTables(); initStations(); initStaff();
  initInventory();
  buildBookingsForDay();
  ensureRegularPool();
  applyDailyWages();

  for(let i=0;i<4;i++){
    if(Game.acceptWalkins) spawnGuestParty();
  }
if(Game.overbookLevel > 0.15){
  toast("Service started ‚Äî WARNING: overbooked night (expect waits).");
}else{
  toast("Service started ‚Äî host is seating (bookings first).");
}
}
function endDay(){
  Game.running=false; Game.paused=false; Game.reportOpen=true;

  // Skill progression (small, steady). Bad cleanliness slows learning.
  const heads = Game.stats.served || 0;
  const learn = U.clamp(0.002 + heads*0.00002, 0.002, 0.010) * U.clamp(0.85 + Game.cleanliness*0.2, 0.80, 1.05);
  Game.skill.cook = U.clamp(Game.skill.cook + learn, 0.85, 1.18);
  Game.skill.bar  = U.clamp(Game.skill.bar  + learn*0.8, 0.85, 1.15);

  saveGame();
  toast("Service finished.");
}

/* -------------------- Simulation -------------------- */
function updateSim(dt){
  const L=DATA.layout;
  // cleanliness baseline
  Game.cleanliness = U.clamp(Game.cleanliness - DATA.cleanlinessDecay*dt, 0, 1);
  if(Game.cleaners>0) Game.cleanliness = U.clamp(Game.cleanliness + (0.0085*Game.cleaners)*dt, 0, 1);

  const avgDirt = Game.tables.reduce((a,t)=>a+t.dirty,0)/Math.max(1,Game.tables.length);
  Game.cleanliness = U.clamp(Game.cleanliness - avgDirt*0.0009*dt, 0, 1);

  // bookings and pacing
  processBookings();
  holdTablesForUpcomingBookings();
  updateQueueTargets();
  processHost(dt);

  // walk-in spawns
  if(Game.acceptWalkins){
    const rn=(Game.rating-DATA.ratingFloor)/(DATA.ratingCeil-DATA.ratingFloor);
    let spawn = DATA.spawnBase + rn*0.18 + (Game.cleanliness-0.75)*0.10;
    spawn = U.clamp(spawn, DATA.spawnMin, DATA.spawnMax);
    Game.spawnAcc += spawn*dt;
    while(Game.spawnAcc>=1){
      Game.spawnAcc -= 1;
      spawnGuestParty();
    }
  }


  // guest movement + seating
  for(const p of Game.guests){
    if(p.state==="DONE") continue;

    const speed = (p.state==="LEAVING") ? 96 : 80;

    
if(p.state==="ARRIVING" || p.state==="QUEUING" || p.state==="WAIT_HOST"){
  const at = U.moveTowards(p.pos, p.target, speed, dt);
  if(at){
    // wait for host to seat you
    p.state = (p.state==="ARRIVING") ? "QUEUING" : p.state;
    const waited = Game.t - p._arrivedAt;

    // bookings get longer patience, but can still walk out if overbooked
    const baseThresh = p.isBooking ? U.rand(34, 58) : U.rand(18, 34);
    const over = U.clamp(Game.overbookLevel, 0, 0.9);
    const thresh = baseThresh * (1 + over*0.55);

    if(waited > thresh){
      p.state="LEAVING";
      p.target={x:L.exit.x, y:L.exit.y};
      p.note = p.isBooking ? "Left (booking wait)" : "Left (queue too long)";
      Game.stats.left += p.size;
      updateRating(p.isBooking ? -0.06 : -0.03);

      if(p.isBooking && p.bookingId){
        const b=Game.bookings.find(x=>x.id===p.bookingId);
        if(b && b.status!=="LEFT" && b.status!=="SEATED"){ 
          b.status="LEFT"; 
          Game.stats.bookings.left += 1;

          // overbooking penalty (walked booking)
          const mul = (b.type==="CRITIC"||b.type==="VIP") ? DATA.overbooking.criticPenaltyMul : 1.0;
          updateRating(-DATA.overbooking.penaltyBase*mul);
        }
      }
    }
  }
}

    if(p.state==="WALK_TO_TABLE"){
      const at = U.moveTowards(p.pos, p.target, speed, dt);
      if(at){
        p.state="SEATED_WAIT_SERVER";
      }
    }

    if(p.state==="SEATED_WAIT_SERVER"){
      if(Game.staff.servers.length===0){
        const waited = Game.t - (p.seatedAt??Game.t);
        if(waited > 22){
          p.state="LEAVING";
          p.target={x:L.exit.x, y:L.exit.y};
          p.note = "Left (no server)";
          Game.stats.left += p.size;
          updateRating(-0.06);
          if(p.tableId) clearTable(p.tableId);
        }
      }
    }

    if(p.state==="WAIT_FOOD"){
      const waited = Game.t - (p.orderedAt ?? Game.t);
      if(waited > 26){ addComplaint(p, "FOOD_WAIT", "Food is taking too long."); }
      if(waited > p.patience*1.55){
        p.state="LEAVING";
        p.target={x:L.exit.x, y:L.exit.y};
        p.note = "Left (waited too long)";
        Game.stats.left += p.size;
        updateRating(-0.07);
        if(p.tableId) clearTable(p.tableId);
      }
      if(p.deliveredAt && Game.t >= p.deliveredAt && p._deliverTicketId){
        const ticket = Game.tickets.find(t=>t.id===p._deliverTicketId);
        if(ticket && !p._received){
          p._received=true;
          finalizeDeliveredParty(p, ticket);
        }
      }
    }

    
if(p.state==="EATING"){
      if(Game.t >= p._leaveAt){
        p.state="READY_TO_PAY";
        p._payRequestedAt = Game.t;
      }
    }

    if(p.state==="READY_TO_PAY"){
      const waited = Game.t - (p._payRequestedAt ?? Game.t);
      if(waited > 24){ addComplaint(p, "PAY_WAIT", "Waiting to pay is too slow."); }
      if(waited > 18){
        p.satisfaction = U.clamp((p.satisfaction ?? 0.6) * U.clamp(1 - (waited-18)/60, 0.75, 1.0), 0.1, 1.0);
        if(!p.note) p.note = "Payment took ages";
      }
      // server will flip state to LEAVING when paid
    }

    // drink complaint check
if(p._drinkTicketId && !p._hadDrink && p.seatedAt){
  const sinceSeat = Game.t - p.seatedAt;
  if(sinceSeat > 16){
    addComplaint(p, "DRINK_WAIT", "Drinks are taking too long.");
  }
}

if(p.state==="LEAVING"){
      const at = U.moveTowards(p.pos, p.target, 98, dt);
      if(at){
        if(!p._reviewed){
          const willReview = (p.type==="CRITIC") || (Math.random()<0.55) || p._lateFlag || p._valueFlag || p._dirtyFlag || p._comped || p.returningRegular;
          if(willReview) makeReview(p);
          p._reviewed=true;
        }
        p.state="DONE";
      }
    }
  }

  processServers(dt);
  processStations(dt);

  for(const t of Game.tickets){
    if(t.status==="READY" && t.finishedAt!=null){
      const party=Game.guests.find(g=>g.id===t.partyId);
      if(party && party.state==="WAIT_FOOD") party.foodReadyAt = party.foodReadyAt ?? Game.t;
    }
  }

  processRunnerDeliveries(dt);
  processCleaning(dt);

  if(Game.t >= DATA.shiftSeconds) endDay();
}

/* -------------------- Rendering -------------------- */
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
/* roundRect polyfill (iOS Safari compatibility) */
(function(){
  try{
    if(typeof CanvasRenderingContext2D !== "undefined" && !CanvasRenderingContext2D.prototype.roundRect){
      CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
        r = (typeof r==="number") ? {tl:r,tr:r,br:r,bl:r} : (r||{tl:0,tr:0,br:0,bl:0});
        const tl=r.tl||0, tr=r.tr||0, br=r.br||0, bl=r.bl||0;
        this.moveTo(x+tl, y);
        this.lineTo(x+w-tr, y);
        this.quadraticCurveTo(x+w, y, x+w, y+tr);
        this.lineTo(x+w, y+h-br);
        this.quadraticCurveTo(x+w, y+h, x+w-br, y+h);
        this.lineTo(x+bl, y+h);
        this.quadraticCurveTo(x, y+h, x, y+h-bl);
        this.lineTo(x, y+tl);
        this.quadraticCurveTo(x, y, x+tl, y);
        return this;
      };
    }
  }catch(e){}
})();
let DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
function resizeCanvas(){
  const r=canvas.getBoundingClientRect();
  const w=Math.floor(r.width*DPR), h=Math.floor(r.height*DPR);
  if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; }
}
window.addEventListener("resize", ()=>{ DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1)); resizeCanvas(); });

function draw(){
  resizeCanvas();
  const w=canvas.width, h=canvas.height, s=DPR;
  ctx.clearRect(0,0,w,h);
  const L=DATA.layout;

  function zone(r, fill, stroke){
    ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(r.x*s, r.y*s, r.w*s, r.h*s, 14*s);
    ctx.fill(); ctx.stroke();
  }
  zone(L.diningRect,"rgba(27,42,77,0.35)","rgba(123,220,255,0.18)");
  zone(L.kitchenRect,"rgba(31,59,43,0.35)","rgba(124,255,138,0.16)");

  // tables (show holds)
  for(const t of Game.tables){
    const x=t.x*s, y=t.y*s;
    const dirt=t.dirty;
    const dirtTint = Math.floor(80 + dirt*120);

    const held = (t.holdForBookingId && Game.t < t.holdUntil);
    ctx.fillStyle= held ? `rgba(90,90,120,0.75)` : `rgba(${dirtTint},42,27,0.78)`;
    ctx.strokeStyle= held ? "rgba(123,220,255,0.35)" : (dirt>0.35 ? "rgba(255,107,107,0.28)" : "rgba(255,209,102,0.25)");
    ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(x,y,90*s,60*s,10*s); ctx.fill(); ctx.stroke();

    ctx.fillStyle="rgba(232,232,234,0.95)";
    ctx.font=`${12*s}px system-ui`;
    ctx.fillText(t.id, x+8*s, y+18*s);
    ctx.fillStyle="rgba(223,230,255,0.75)";
    ctx.font=`${10*s}px system-ui`;
    ctx.fillText(`${t.seats}-top`, x+50*s, y+18*s);

    for(let i=0;i<t.seats;i++){
      ctx.beginPath();
      ctx.fillStyle=(i<t.occupied)?"rgba(123,220,255,0.95)":"rgba(255,255,255,0.18)";
      ctx.arc(x+(10+i*12)*s, y+42*s, 3.8*s, 0, Math.PI*2);
      ctx.fill();
    }

    if(held){
      ctx.fillStyle="rgba(223,230,255,0.95)";
      ctx.font=`${11*s}px system-ui`;
      ctx.fillText("‚è±", x+72*s, y+46*s);
    } else if(t.dirty>0.05){
      const bx=x+8*s, by=y+54*s, bw=74*s, bh=6*s;
      ctx.fillStyle="rgba(11,15,31,0.9)"; ctx.fillRect(bx,by,bw,bh);
      ctx.fillStyle="rgba(255,107,107,0.65)"; ctx.fillRect(bx,by,bw*t.dirty,bh);
    }
  }

  // stations
  for(const sid of DATA.stations){
    const st=Game.stations[sid], p=L.stations[sid];
    const x=p.x*s, y=p.y*s;
    ctx.fillStyle="rgba(59,31,52,0.70)";
    ctx.strokeStyle="rgba(255,107,107,0.22)";
    ctx.lineWidth=2*s;
    ctx.beginPath(); ctx.roundRect(x,y,120*s,70*s,12*s); ctx.fill(); ctx.stroke();
    ctx.fillStyle="rgba(232,232,234,0.95)";
    ctx.font=`${12*s}px system-ui`;
    ctx.fillText(sid, x+10*s, y+20*s);
    ctx.fillStyle="rgba(223,230,255,0.75)";
    ctx.fillText(`Q:${st.queue.length} W:${st.active.length}`, x+10*s, y+42*s);
  }

  // host / pickup
  ctx.fillStyle="rgba(123,220,255,0.18)";
  ctx.strokeStyle="rgba(123,220,255,0.30)";
  ctx.lineWidth=2*s;
  ctx.beginPath(); ctx.roundRect((L.host.x-18)*s,(L.host.y-18)*s,130*s,78*s,14*s); ctx.fill(); ctx.stroke();
  ctx.fillStyle="rgba(223,230,255,0.85)";
  ctx.font=`${12*s}px system-ui`;
  ctx.fillText("HOST",(L.host.x+8)*s,(L.host.y+8)*s);

// queue zone
ctx.fillStyle="rgba(255,209,102,0.10)";
ctx.strokeStyle="rgba(255,209,102,0.22)";
ctx.lineWidth=2*s;
ctx.beginPath(); ctx.roundRect((L.queueStart.x-22)*s,(L.queueStart.y-18)*s,170*s,320*s,14*s); ctx.fill(); ctx.stroke();
ctx.fillStyle="rgba(223,230,255,0.75)";
ctx.font=`${12*s}px system-ui`;
ctx.fillText("QUEUE",(L.queueStart.x+8)*s,(L.queueStart.y+8)*s);

  ctx.fillStyle="rgba(124,255,138,0.14)";
  ctx.strokeStyle="rgba(124,255,138,0.22)";
  ctx.beginPath(); ctx.roundRect((L.passPickup.x-22)*s,(L.passPickup.y-18)*s,140*s,60*s,14*s); ctx.fill(); ctx.stroke();
  ctx.fillStyle="rgba(223,230,255,0.85)";
  ctx.fillText("PICKUP",(L.passPickup.x+8)*s,(L.passPickup.y+8)*s);

  // guests
  for(const g of Game.guests){
    if(g.state==="DONE") continue;
    const px=g.pos.x*s, py=g.pos.y*s;

    let ring="rgba(255,209,102,0.85)";
    if(g.state==="SEATED_WAIT_SERVER"||g.state==="ORDER_BEING_TAKEN") ring="rgba(123,220,255,0.85)";
    if(g.state==="WAIT_FOOD") ring="rgba(255,107,107,0.85)";
    if(g.state==="EATING") ring="rgba(124,255,138,0.85)";
    if(g.state==="LEAVING") ring="rgba(223,230,255,0.70)";

    ctx.beginPath();
    ctx.fillStyle="rgba(36,49,82,0.95)";
    ctx.arc(px,py,7*s,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle=ring;
    ctx.lineWidth=2*s;
    ctx.stroke();

    ctx.fillStyle="rgba(223,230,255,0.95)";
    ctx.font=`${10*s}px system-ui`;
    let icon="";
    if(g.type==="CRITIC"||g.type==="VIP") icon="‚òÖ";
    else if(g.type==="FAMILY") icon="F";
    else icon="R";
    ctx.fillText(icon, px-3.5*s, py+3.5*s);

    if(g.isBooking) ctx.fillText("B", px-3.5*s, py-9*s);
    if(g.returningRegular) ctx.fillText("‚ù§", px+7*s, py+8*s);
    if(g.state==="WAIT_FOOD") ctx.fillText("!", px+9*s, py-7*s);
    if(g.state==="QUEUING") ctx.fillText("‚Ä¶", px+9*s, py-7*s);
    if(g.state==="EATING") ctx.fillText("üçΩ", px+9*s, py-7*s);
  }

  // staff
  function drawStaff(a, label, colorFill){
    const px=a.pos.x*s, py=a.pos.y*s;
    ctx.beginPath();
    ctx.fillStyle=colorFill;
    ctx.arc(px,py,7*s,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(223,230,255,0.65)";
    ctx.lineWidth=2*s;
    ctx.stroke();
    ctx.fillStyle="rgba(7,8,16,0.95)";
    ctx.font=`${9*s}px system-ui`;
    ctx.fillText(label, px-8*s, py+3*s);
  }
  for(const sv of Game.staff.servers) drawStaff(sv,"SV","#7bdcff");
  for(const rn of Game.staff.runners) drawStaff(rn,"RN","#7cff8a");
  for(const cl of Game.staff.cleaners) drawStaff(cl,"CL","#ffd166");
  if(Game.host) drawStaff(Game.host,"HQ","#d7a6ff");

  // Cleanliness meter
  const mx=720*s,my=250*s,mw=320*s,mh=18*s;
  ctx.fillStyle="rgba(15,20,38,0.9)";
  ctx.strokeStyle="rgba(43,51,80,0.9)";
  ctx.lineWidth=2*s;
  ctx.beginPath(); ctx.roundRect(mx,my,mw,mh,999); ctx.fill(); ctx.stroke();
  ctx.fillStyle="rgba(123,220,255,0.85)";
  ctx.beginPath(); ctx.roundRect(mx,my,mw*Game.cleanliness,mh,999); ctx.fill();
  ctx.fillStyle="rgba(223,230,255,0.85)";
  ctx.font=`${12*s}px system-ui`;
  ctx.fillText("Cleanliness",mx,my-6*s);

  if(Game.reportOpen){
    ctx.fillStyle="rgba(7,8,16,0.80)";
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle="rgba(223,230,255,0.95)";
    ctx.font=`${22*s}px system-ui`;
    ctx.fillText(`End of Day ${Game.day} Report`, 30*s, 40*s);
    ctx.font=`${14*s}px system-ui`;
    const avg = Game.stats.waitCount? (Game.stats.waitTotal/Game.stats.waitCount):0;
    const profit = Game.stats.revenue-Game.stats.costs-Game.stats.wages;
    const fc = (Game.stats.revenue>0? foodCostPctToday():0);
    const b=Game.stats.bookings;
    const lines=[
      ["Revenue", U.fmtMoney(Game.stats.revenue)],
      ["Costs", "-"+U.fmtMoney(Game.stats.costs)],
      ["Wages", "-"+U.fmtMoney(Game.stats.wages)],
      ["Profit", U.fmtMoney(profit)],
      ["Food Cost %", fc.toFixed(1)+"%"],
      ["Heads Served", String(Game.stats.served)],
      ["Left", String(Game.stats.left)],
      ["Avg Ticket Time", Math.round(avg)+"s"],
      ["Stockouts (86)", String(Game.stats.issues.stockout||0)],
      ["Incidents", `Refire:${Game.stats.refires||0} Burn:${Game.stats.burns||0} Comp:${Math.round(Game.stats.comps||0)}`],
      ["Tips", `$${Math.round(Game.stats.tips||0)}`],
      ["Complaints fixed", String(Game.stats.complaintsResolved||0)],
      ["Overbooking", (Game.overbookLevel>0.35?"HIGH":(Game.overbookLevel>0.15?"MED":"none"))],
      ["Bookings", `Total:${b.total} Arr:${b.arrived} NoShow:${b.noShow} Seated:${b.seated} Left:${b.left}`]
    ];
    let y=70*s;
    for(const [k,v] of lines){
      ctx.fillStyle="rgba(166,166,173,0.95)"; ctx.fillText(k, 30*s, y);
      ctx.fillStyle="rgba(223,230,255,0.95)"; ctx.fillText(v, 260*s, y);
      y += 24*s;
    }
    ctx.fillStyle="rgba(123,220,255,0.95)";
    ctx.fillText("Tap/click to start next day", 30*s, h-40*s);
  }
}

/* -------------------- UI -------------------- */
function fmtTime(sec){
  const m=Math.floor(sec/60), s=sec%60;
  return String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
}
function buildMenuPanel(){
  const body=document.getElementById("menuRows");
  body.innerHTML="";

  function sectionRow(title){
    body.insertAdjacentHTML("beforeend", `
      <tr>
        <td colspan="5" style="background:transparent;border:none;padding:6px 2px;">
          <span class="pill">${title}</span>
        </td>
      </tr>
    `);
  }

  sectionRow("Food");
  for(const d of DATA.foodMenu){
    const price=getPrice(d.id);
    const profit=price-d.cost;
    const fc=price>0? (d.cost/price)*100 : 0;
    const fcClass = (fc < 28) ? "goodTxt" : (fc <= 35 ? "" : "warnTxt");
    const profitClass = (profit >= 12) ? "goodTxt" : (profit >= 7 ? "" : "warnTxt");
    body.insertAdjacentHTML("beforeend",`
      <tr data-dish="${d.id}">
        <td><b>${d.name}</b><div class="small">${d.tag}</div></td>
        <td>
          <div class="pricebox">
            <button class="miniBtn" data-act="dec">$-</button>
            <input type="number" min="5" step="1" value="${Math.round(price)}" data-act="set">
            <button class="miniBtn" data-act="inc">+$</button>
          </div>
        </td>
        <td class="${profitClass}">$${profit.toFixed(0)}</td>
        <td class="${fcClass}">${fc.toFixed(0)}%</td>
        <td><span id="stock-${d.id}" class="small">‚Äî</span></td>
      </tr>
    `);
  }

  sectionRow("Drinks (Bar)");
  for(const d of DATA.drinkMenu){
    const price=getPrice(d.id);
    const profit=price-d.cost;
    const fc=price>0? (d.cost/price)*100 : 0;
    const fcClass = (fc < 18) ? "goodTxt" : (fc <= 28 ? "" : "warnTxt");
    const profitClass = (profit >= 5) ? "goodTxt" : (profit >= 3 ? "" : "warnTxt");
    body.insertAdjacentHTML("beforeend",`
      <tr data-dish="${d.id}">
        <td><b>${d.name}</b><div class="small">${d.tag}</div></td>
        <td>
          <div class="pricebox">
            <button class="miniBtn" data-act="dec">$-</button>
            <input type="number" min="3" step="1" value="${Math.round(price)}" data-act="set">
            <button class="miniBtn" data-act="inc">+$</button>
          </div>
        </td>
        <td class="${profitClass}">$${profit.toFixed(0)}</td>
        <td class="${fcClass}">${fc.toFixed(0)}%</td>
        <td><span id="stock-${d.id}" class="small">‚Äî</span></td>
      </tr>
    `);
  }

  // stock display
  for(const d of allMenu()){
    const el = document.getElementById("stock-"+d.id);
    if(!el) continue;
    const s = dishStock(d.id);
    if(s<=0){
      el.innerHTML = "<span class='badTxt'><b>86</b></span>";
    }else if(s<=DATA.inventory.lowThreshold){
      el.innerHTML = "<span class='warnTxt'><b>"+s+"</b></span>";
    }else{
      el.textContent = String(s);
    }
  }

  body.onclick=(e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const tr=btn.closest("tr"); const id=tr?.dataset?.dish; if(!id) return;
    const cur=getPrice(id);
    const step=(id==="steak"||id==="mocktail")?2:1;
    if(btn.dataset.act==="inc") setPrice(id,cur+step);
    if(btn.dataset.act==="dec") setPrice(id,cur-step);
    buildMenuPanel();
  };
  body.onchange=(e)=>{
    const inp=e.target.closest("input[data-act='set']"); if(!inp) return;
    const tr=inp.closest("tr"); const id=tr?.dataset?.dish; if(!id) return;
    const v=Number(inp.value); if(!isFinite(v)) return;
    setPrice(id,v);
    buildMenuPanel();
  };

  body.onclick=(e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const tr=btn.closest("tr"); const id=tr?.dataset?.dish; if(!id) return;
    const cur=getPrice(id);
    const step=(id==="steak")?2:1;
    if(btn.dataset.act==="inc") setPrice(id,cur+step);
    if(btn.dataset.act==="dec") setPrice(id,cur-step);
    buildMenuPanel();
  };
  body.onchange=(e)=>{
    const inp=e.target.closest("input[data-act='set']"); if(!inp) return;
    const tr=inp.closest("tr"); const id=tr?.dataset?.dish; if(!id) return;
    const v=Number(inp.value); if(!isFinite(v)) return;
    setPrice(id,v);
    buildMenuPanel();
  };
}

function renderBookings(){
  const box=document.getElementById("bookings");
  document.getElementById("bookingPill").textContent = String(Game.bookings.length);
  const show = Game.bookings.slice(0,12);
  box.innerHTML = show.length ? "" : `<div class="small">No bookings loaded.</div>`;
  for(const b of show){
    const status=b.status;
    const statusColor = (status==="SEATED") ? "goodTxt" : (status==="NO_SHOW"||status==="LEFT") ? "badTxt" : "warnTxt";
    const badge = b.type==="CRITIC"||b.type==="VIP" ? "‚òÖ" : (b.type==="FAMILY" ? "F" : "R");
    // indicate if a table is currently held for this booking
    const held = Game.tables.some(t=>t.holdForBookingId===b.id && Game.t < t.holdUntil);
    const heldTag = held ? `<span class="tag">‚è± HOLD</span>` : "";
    box.insertAdjacentHTML("beforeend",`
      <div class="booking">
        <div class="top">
          <div><b>${b.name}</b> <span class="small">(${badge} ¬∑ ${b.size}p)</span>
            <div class="small">ETA ${fmtTime(b.eta)} ${heldTag}</div>
          </div>
          <div class="${statusColor}"><b>${status}</b></div>
        </div>
      </div>
    `);
  }
}

function renderRegulars(){
  const box=document.getElementById("regulars");
  const list = regularsList().slice(0,10);
  document.getElementById("regularPill").textContent = String(Object.keys(Game.regularsDB).length);
  box.innerHTML = list.length ? "" : `<div class="small">No regulars yet ‚Äî serve a few REGULAR guests.</div>`;
  for(const r of list){
    const fav = getDish(r.favDishId)?.name || "Unknown";
    const pct = Math.round((r.loyalty||0.5)*100);
    box.insertAdjacentHTML("beforeend",`
      <div class="regular">
        <div class="top">
          <div>
            <b>${r.name}</b> <span class="small">‚ù§ loyalty ${pct}%</span>
            <div class="small">Usual: ${fav} ¬∑ Visits: ${r.visits||0}</div>
          </div>
          <div style="min-width:100px">
            <div class="bar"><div style="width:${pct}%"></div></div>
          </div>
        </div>
      </div>
    `);
  }
}

function renderReviews(){
  const box=document.getElementById("reviews");
  const list=Game.reviews.slice(0,12);
  document.getElementById("reviewCount").textContent = String(Game.reviews.length);
  box.innerHTML = list.length ? "" : `<div class="small">No reviews yet ‚Äî serve a few tables.</div>`;
  for(const r of list){
    const tags = r.tags && r.tags.length ? r.tags.map(t=>`<span class="tag">${t}</span>`).join(" ") : "";
    box.insertAdjacentHTML("beforeend",`
      <div class="review">
        <div class="top">
          <div>
            <b>${r.name}</b> <span class="small">(${r.dish})</span>
            <div class="stars">${r.starsText}</div>
          </div>
          <div style="text-align:right">${tags}</div>
        </div>
        <div class="small" style="margin-top:6px; color:#dfe6ff;">${r.text}</div>
      </div>
    `);
  }
}

function addComplaint(party, kind, msg){
  if(!party) return;
  party._complaintKinds = party._complaintKinds || {};
  if(party._complaintKinds[kind]) return;
  party._complaintKinds[kind] = true;

  const c={ id:"C"+U.uid(), partyId:party.id, tableId:party.tableId, kind, msg, t:Game.t, resolved:false };
  Game.complaints.push(c);
  Game.stats.complaintsRaised += 1;
}

function resolveComplaint(cid, action){
  const c=Game.complaints.find(x=>x.id===cid);
  if(!c || c.resolved) return;
  const p=Game.guests.find(g=>g.id===c.partyId);

  if(action==="APOLOGY"){
    if(p){
      p.satisfaction = U.clamp((p.satisfaction ?? 0.6) + 0.05, 0.1, 1.0);
      p.note = p.note || "Manager apology";
    }
  }
  if(action==="COMP15"){
    if(p){
      const base = Math.max(0, (p.billAmount ?? 0) * 0.15);
      p.compAmount = (p.compAmount||0) + base;
      p._compFlag = true;
      Game.stats.comps += base;
      p.satisfaction = U.clamp((p.satisfaction ?? 0.6) + 0.08, 0.1, 1.0);
      p.note = p.note || "Manager comp";
    }
  }

  c.resolved=true;
  c.action=action;
  c.resolvedAt=Game.t;
  Game.stats.complaintsResolved += 1;
}

function renderComplaints(){
  const box=document.getElementById("complaints");
  const pill=document.getElementById("complaintPill");
  if(!box) return;
  const open = Game.complaints.filter(c=>!c.resolved).slice(-10).reverse();
  if(pill) pill.textContent = String(open.length);

  box.innerHTML = open.length ? "" : `<div class="small">No active complaints.</div>`;
  for(const c of open){
    const p = Game.guests.find(g=>g.id===c.partyId);
    const badge = p ? (p.type==="CRITIC"||p.type==="VIP" ? "‚òÖ" : (p.type==="FAMILY" ? "F" : "R")) : "‚Ä¢";
    const tno = c.tableId ?? (p?.tableId ?? "?");
    box.insertAdjacentHTML("beforeend",`
      <div class="booking">
        <div class="top">
          <div><b>${badge} Table ${tno}</b> <span class="small">¬∑ ${c.kind}</span>
            <div class="small">${c.msg}</div>
            <div class="small">${fmtTime(Math.floor(c.t))}</div>
          </div>
          <div style="display:flex; gap:6px; align-items:flex-start;">
            <button class="miniBtn" data-cid="${c.id}" data-act="APOLOGY">Apology</button>
            <button class="miniBtn" data-cid="${c.id}" data-act="COMP15">Comp 15%</button>
          </div>
        </div>
      </div>
    `);
  }

  box.onclick=(e)=>{
    const btn=e.target.closest("button[data-cid]"); if(!btn) return;
    resolveComplaint(btn.dataset.cid, btn.dataset.act);
    renderComplaints();
  };
}

function updateUI(){
  document.getElementById("cash").textContent=U.fmtMoney(Game.cash);
  document.getElementById("rating").textContent=U.star(Game.rating);
  document.getElementById("served").textContent=String(Game.stats.served);

  const avg=Game.stats.waitCount? (Game.stats.waitTotal/Game.stats.waitCount):0;
  document.getElementById("avgWait").textContent=Math.round(avg)+"s";

  const profit = Game.stats.revenue-Game.stats.costs-Game.stats.wages;
  document.getElementById("profitToday").textContent=U.fmtMoney(profit);

  const fc = (Game.stats.revenue>0? foodCostPctToday():0);
  document.getElementById("foodCostPct").textContent=fc.toFixed(1)+"%";

  document.getElementById("dayPill").textContent="Day "+Game.day;
  document.getElementById("speedText").textContent=Game.speedList[Game.speedIdx]+"√ó";
  document.getElementById("ticketCount").textContent=String(Game.tickets.filter(t=>!t._served).length);

  const remain=Math.max(0, DATA.shiftSeconds-Game.t);
  document.getElementById("shiftTime").textContent=fmtTime(Math.floor(remain));

// Queue + overbooking indicator
const qlen = Game.guests.filter(g=>g.state==="ARRIVING"||g.state==="QUEUING"||g.state==="WAIT_HOST").length;
document.getElementById("queueLen").textContent = String(qlen);
const ob = Game.overbookLevel||0;
const pill = document.getElementById("overbookPill");
if(ob > 0.35){ pill.textContent = "Overbooking: HIGH"; pill.style.borderColor="#7a2d33"; }
else if(ob > 0.15){ pill.textContent = "Overbooking: MED"; pill.style.borderColor="#ffd166"; }
else { pill.textContent = "Overbooking: none"; pill.style.borderColor="#2b3350"; }

  document.getElementById("btnStart").disabled=Game.running;
  document.getElementById("btnPause").disabled=!Game.running;
  document.getElementById("btnPause").textContent=Game.paused?"Resume":"Pause";

  const box=document.getElementById("tickets");
  const live=Game.tickets.slice(0,12);
  box.innerHTML = live.length ? "" : `<div class="small">No tickets yet. Server needs seated guests.</div>`;
  for(const t of live){
    const waited = Game.t - t.orderedAt;
    const prog = U.clamp(t.stepIndex/(t.steps.length||1),0,1);
    const status = t.status==="READY" ? "READY (runner)" : "IN PROGRESS";
    box.insertAdjacentHTML("beforeend",`
      <div class="ticket">
        <div class="top">
          <div><b>${t.dishName}</b><div class="small">Ticket ${t.id} ¬∑ ${t.kind==='DRINK'?'DR ¬∑ ':'FOOD ¬∑ '}${t.qty}x ¬∑ $${Math.round(t.price)}</div></div>
          <div style="text-align:right">
            <div class="small">Wait ${Math.round(waited)}s</div>
            <div class="small">${status}</div>
          </div>
        </div>
        <div class="bar"><div style="width:${(prog*100).toFixed(0)}%"></div></div>
        <div class="small" style="margin-top:6px;">
          Step ${Math.min(t.stepIndex+1, t.steps.length)}/${t.steps.length} ‚Äî ${t.stepIndex<t.steps.length?t.steps[t.stepIndex].station:"DONE"}
        </div>
      </div>
    `);
  }

  document.getElementById("btnHireCook").textContent=`Hire Cook (+$${Game.wages.cook}/day)`;
  document.getElementById("btnHireCleaner").textContent=`Hire Cleaner (+$${Game.wages.cleaner}/day)`;
  document.getElementById("btnHireServer").textContent=`Hire Server (+$${Game.wages.server}/day)`;
  document.getElementById("btnHireRunner").textContent=`Hire Runner (+$${Game.wages.runner}/day)`;
  document.getElementById("btnHireBartender") && (document.getElementById("btnHireBartender").textContent=`Hire Bartender (+$${Game.wages.bartender}/day)`);
  const sp = document.getElementById("skillPill");
  if(sp){ sp.textContent = `Skill: Cook ${Game.skill.cook.toFixed(2)} ¬∑ Bar ${Game.skill.bar.toFixed(2)}`; }
  const mp = document.getElementById("moneyPill");
  if(mp){ mp.textContent = `Tips: $${Math.round(Game.stats.tips||0)} ¬∑ Comps: $${Math.round(Game.stats.comps||0)} ¬∑ Fix:${Game.stats.complaintsResolved||0}`; }
  const e6 = document.getElementById("eightySix");
  if(e6){
    const sold = allMenu().filter(d=>dishStock(d.id)<=0).map(d=>d.name);
    e6.textContent = sold.length ? sold.slice(0,6).join(", ") + (sold.length>6?"‚Ä¶":"") : "None";
  }


// update stock numbers in menu (cheap update)
for(const d of allMenu()){
  const el = document.getElementById("stock-"+d.id);
  if(!el) continue;
  const s = dishStock(d.id);
  if(s<=0){ el.innerHTML = "<span class='badTxt'><b>86</b></span>"; }
  else if(s<=DATA.inventory.lowThreshold){ el.innerHTML = "<span class='warnTxt'><b>"+s+"</b></span>"; }
  else { el.textContent = String(s); }
}function setMode(mode){
  Game.mode = (mode==="BUILD") ? "BUILD" : "OPERATE";
  const mp=document.getElementById("modePill"); if(mp) mp.textContent = Game.mode;
  const bc=document.getElementById("buildCard"); if(bc) bc.style.display = (Game.mode==="BUILD") ? "" : "none";

  // Disable service controls while building
  const canService = (Game.mode==="OPERATE");
  const s = document.getElementById("btnStart"); if(s) s.disabled = !canService || Game.serviceRunning;
  const r = document.getElementById("btnRush");  if(r) r.disabled = !canService || Game.serviceRunning;

  // If switching to build mid-service, pause safely
  if(Game.mode==="BUILD" && Game.serviceRunning){
    Game.serviceRunning=false;
    const p=document.getElementById("btnPause"); if(p) p.disabled=true;
  }

  renderBuildPanel();
  saveGame();
}

function countOpenTables(){
  return Game.tables.filter(t=>t.enabled!==false).length;
}

function renderBuildPanel(){
  const bc=document.getElementById("buildCard"); if(!bc) return;
  const openTxt=document.getElementById("openTablesTxt");
  const kTxt=document.getElementById("kitchenLvTxt");
  const bTxt=document.getElementById("barLvTxt");
  const dTxt=document.getElementById("decorLvTxt");
  if(openTxt) openTxt.textContent = `${countOpenTables()} / ${Game.tables.length}`;
  if(kTxt) kTxt.textContent = String((Game.build||{}).kitchenLevel||0);
  if(bTxt) bTxt.textContent = String((Game.build||{}).barLevel||0);
  if(dTxt) dTxt.textContent = String((Game.build||{}).decorLevel||0);

  const grid=document.getElementById("tableToggles"); 
  if(grid){
    grid.innerHTML="";
    for(const t of Game.tables){
      const on = (t.enabled!==false);
      const cls = on ? "tblBtn" : "tblBtn off";
      grid.insertAdjacentHTML("beforeend", `<button class="${cls}" data-tid="${t.id}">${t.id}<small>${t.seats}-top</small></button>`);
    }
  }

  // update build day pill
  const bp=document.getElementById("buildPill"); if(bp) bp.textContent = `Day ${Math.max(0,(Game.day||1)-1)}`;
}

function spend(cost){
  if(Game.cash < cost){ toast("Not enough cash."); return false; }
  Game.cash -= cost;
  return true;
}

function addTable(){
  const closed = Game.tables.find(t=>t.enabled===false);
  if(!closed){ toast("All tables already open."); return; }
  if(!spend(200)) return;
  closed.enabled=true;
  syncTableMask();
  toast(`${closed.id} opened.`);
  renderBuildPanel(); updateUI(); saveGame();
}

function removeTable(){
  const open = Game.tables.filter(t=>t.enabled!==false);
  if(open.length<=2){ toast("Keep at least 2 tables open."); return; }
  const t = open[open.length-1];
  if(t.occupied!==0){ toast("Can't close an occupied table."); return; }
  Game.cash += 120;
  t.enabled=false;
  t.holdForBookingId=null; t.holdUntil=0;
  syncTableMask();
  toast(`${t.id} closed.`);
  renderBuildPanel(); updateUI(); saveGame();
}

function upgrade(which){
  const up = (Game.build||{});
  if(which==="KITCHEN"){
    const lvl=up.kitchenLevel||0;
    const cost=350 + lvl*180;
    if(lvl>=5){ toast("Kitchen at max."); return; }
    if(!spend(cost)) return;
    up.kitchenLevel=lvl+1;
    toast(`Kitchen upgraded to Lv ${up.kitchenLevel}.`);
  }
  if(which==="BAR"){
    const lvl=up.barLevel||0;
    const cost=300 + lvl*160;
    if(lvl>=5){ toast("Bar at max."); return; }
    if(!spend(cost)) return;
    up.barLevel=lvl+1;
    toast(`Bar upgraded to Lv ${up.barLevel}.`);
  }
  if(which==="DECOR"){
    const lvl=up.decorLevel||0;
    const cost=250 + lvl*140;
    if(lvl>=6){ toast("Decor at max."); return; }
    if(!spend(cost)) return;
    up.decorLevel=lvl+1;
    toast(`Decor upgraded to Lv ${up.decorLevel}.`);
  }
  Game.build=up;
  renderBuildPanel(); updateUI(); saveGame();
}

function syncTableMask(){
  if(!Game.build) Game.build={};
  Game.build.tableMask = Game.tables.map(t=>t.enabled!==false);
}

  renderBookings();
  renderRegulars();
  renderReviews();
  renderComplaints();
}

/* -------------------- Save/Load -------------------- */
function saveGame(){
  localStorage.setItem("rtycoon_save_v220", JSON.stringify({
    day:Game.day,cash:Game.cash,rating:Game.rating,cleanliness:Game.cleanliness,
    cooks:Game.cooks,cleaners:Game.cleaners,servers:Game.servers,runners:Game.runners,bartenders:Game.bartenders,
    skill:Game.skill,
    acceptWalkins:Game.acceptWalkins,
    prices:Game.prices,reviews:Game.reviews,
    regularsDB:Game.regularsDB,
    build:Game.build,
    mode:Game.mode
  }));
}
function loadGame(){
  const raw=localStorage.getItem("rtycoon_save_v220");
  if(!raw) return false;
  try{
    const s=JSON.parse(raw);
    Game.day=s.day??1; Game.cash=s.cash??420; Game.rating=s.rating??3.6; Game.cleanliness=s.cleanliness??0.92;
    Game.cooks=s.cooks??3; Game.cleaners=s.cleaners??0; Game.servers=s.servers??1; Game.runners=s.runners??1; Game.bartenders=s.bartenders??1;
    Game.skill = (s.skill && typeof s.skill==='object') ? { cook:(s.skill.cook??1.0), bar:(s.skill.bar??1.0) } : { cook:1.0, bar:1.0 };
    Game.acceptWalkins = (s.acceptWalkins??true);
    Game.prices=s.prices??{};
    Game.reviews=Array.isArray(s.reviews)?s.reviews:[];
    Game.regularsDB = (s.regularsDB && typeof s.regularsDB==="object") ? s.regularsDB : {};
    Game.build = (s.build && typeof s.build==='object') ? s.build : null;
    Game.mode = (s.mode==='BUILD' || s.mode==='OPERATE') ? s.mode : 'OPERATE';
    return true;
  }catch{return false;}
}


function ensureBuildDefaults(){
  const n = DATA.layout.tables.length;
  Game.build = Game.build && typeof Game.build==='object' ? Game.build : {};
  if(!Array.isArray(Game.build.tableMask) || Game.build.tableMask.length!==n){
    // Start smaller so "build" feels real: open first 4 tables by default.
    Game.build.tableMask = Array.from({length:n}, (_,i)=> i < 4);
  }
  Game.build.kitchenLevel = Game.build.kitchenLevel ?? 0;
  Game.build.barLevel    = Game.build.barLevel ?? 0;
  Game.build.decorLevel  = Game.build.decorLevel ?? 0;
  Game.mode = (Game.mode==='BUILD' || Game.mode==='OPERATE') ? Game.mode : 'OPERATE';
}
function resetAll(){
  localStorage.removeItem("rtycoon_save_v220");
  Game.day=1; Game.cash=420; Game.rating=3.6; Game.cleanliness=0.92;
  Game.cooks=3; Game.cleaners=0; Game.servers=1; Game.runners=1; Game.bartenders=1;
  Game.skill={cook:1.00, bar:1.00};
  Game.acceptWalkins=true;
  Game.prices={}; Game.reviews=[];
  Game.regularsDB={};
  Game.running=false; Game.paused=false; Game.reportOpen=false;
  initTables(); initStations(); initStaff(); initInventory(); Game.guests=[]; Game.tickets=[];
  buildMenuPanel();
  toast("Reset complete.");
}

/* -------------------- Controls -------------------- */
document.getElementById("btnStart")?.addEventListener("click", ()=>startDay());
document.getElementById("btnPause")?.addEventListener("click", ()=>{ if(Game.running) Game.paused=!Game.paused; });
document.getElementById("btnSpeed")?.addEventListener("click", ()=>{ Game.speedIdx=(Game.speedIdx+1)%Game.speedList.length; });
document.getElementById("btnReset")?.addEventListener("click", ()=>resetAll());

document.getElementById("btnModeBuild")?.addEventListener("click", ()=>setMode("BUILD"));
document.getElementById("btnModeOperate")?.addEventListener("click", ()=>setMode("OPERATE"));

document.getElementById("btnAddTable")?.addEventListener("click", ()=>addTable());
document.getElementById("btnRemoveTable")?.addEventListener("click", ()=>removeTable());
document.getElementById("btnUpKitchen")?.addEventListener("click", ()=>upgrade("KITCHEN"));
document.getElementById("btnUpBar")?.addEventListener("click", ()=>upgrade("BAR"));
document.getElementById("btnUpDecor")?.addEventListener("click", ()=>upgrade("DECOR"));

document.getElementById("tableToggles")?.addEventListener("click", (e)=>{
  const b=e.target.closest("button[data-tid]"); if(!b) return;
  const t=Game.tables.find(x=>x.id===b.dataset.tid); if(!t) return;
  if(t.occupied!==0){ toast("Can't close an occupied table."); return; }
  t.enabled = !t.enabled;
  syncTableMask();
  renderBuildPanel(); updateUI(); saveGame();
});

// Jump buttons: pan the scrollable canvasWrap on mobile
function jumpTo(pt){
  const wrap=document.querySelector(".canvasWrap");
  if(!wrap) return;
  wrap.scrollLeft = Math.max(0, pt.x - wrap.clientWidth/2);
  wrap.scrollTop  = Math.max(0, pt.y - wrap.clientHeight/2);
}
document.getElementById("btnJumpDining")?.addEventListener("click", ()=>jumpTo({x:DATA.layout.diningRect.x+DATA.layout.diningRect.w/2, y:DATA.layout.diningRect.y+DATA.layout.diningRect.h/2}));
document.getElementById("btnJumpKitchen")?.addEventListener("click", ()=>jumpTo({x:DATA.layout.kitchenRect.x+DATA.layout.kitchenRect.w/2, y:DATA.layout.kitchenRect.y+DATA.layout.kitchenRect.h/2}));
document.getElementById("btnJumpDoor")?.addEventListener("click", ()=>jumpTo({x:DATA.layout.entry.x, y:DATA.layout.entry.y}));
document.getElementById("btnHireCook")?.addEventListener("click", ()=>{ Game.cooks+=1; saveGame(); toast("Hired a cook."); });
document.getElementById("btnHireCleaner")?.addEventListener("click", ()=>{ Game.cleaners+=1; saveGame(); toast("Hired a cleaner."); });
document.getElementById("btnHireServer")?.addEventListener("click", ()=>{ Game.servers+=1; saveGame(); toast("Hired a server."); });
document.getElementById("btnHireRunner")?.addEventListener("click", ()=>{ Game.runners+=1; saveGame(); toast("Hired a runner."); });
document.getElementById("btnHireBartender")?.addEventListener("click", ()=>{ 
  Game.bartenders+=1; saveGame(); toast("Hired a bartender."); 
});
document.getElementById("btnTrain")?.addEventListener("click", ()=>{
  if(Game.cash < 250){ toast("Not enough cash for training."); return; }
  Game.cash -= 250;
  Game.skill.cook = U.clamp(Game.skill.cook + 0.015, 0.85, 1.20);
  Game.skill.bar  = U.clamp(Game.skill.bar  + 0.012, 0.85, 1.20);
  saveGame();
  toast("Training complete (+skill).");
});
document.getElementById("btnRush")?.addEventListener("click", ()=>{
  if(!Game.running){ toast("Start service first, then hit Rush."); return; }
  for(let i=0;i<12;i++) spawnGuestParty();
  toast("Rush: big wave at the door!");
});
document.getElementById("walkinsToggle")?.addEventListener("change",(e)=>{
  Game.acceptWalkins = !!e.target.checked;
  saveGame();
  toast(Game.acceptWalkins ? "Walk-ins ON" : "Walk-ins OFF");
});

canvas.addEventListener("pointerdown", ()=>{
  if(Game.reportOpen){
    Game.day += 1;
    Game.reportOpen=false;
    Game.cleanliness = U.clamp(Game.cleanliness+0.10,0,1);
    saveGame();
    toast("New day. Regulars remember you now üôÇ");
  }
});

/* -------------------- Main loop -------------------- */
let last=U.now();
function loop(){
  const now=U.now();
  let dt=U.clamp(now-last,0,0.05);
  last=now;

  if(Game.running && !Game.paused){
    const sdt=dt*Game.speedList[Game.speedIdx];
    Game.t += sdt;
    updateSim(sdt);
  }
  updateUI();
  try{ draw(); }catch(e){ showFatalError(e); Game._drawFailed=true; }
  requestAnimationFrame(loop);
}

/* -------------------- Boot -------------------- */
(function boot(){
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){
      r=Math.min(r,w/2,h/2);
      this.beginPath();
      this.moveTo(x+r,y);
      this.arcTo(x+w,y,x+w,y+h,r);
      this.arcTo(x+w,y+h,x,y+h,r);
      this.arcTo(x,y+h,x,y,r);
      this.arcTo(x,y,x+w,y,r);
      this.closePath();
      return this;
    }
  }
  initTables(); initStations();
  loadGame();
  initStaff();
  initInventory();
  ensureRegularPool();
  for(const d of allMenu()){ if(!(d.id in Game.prices)) Game.prices[d.id]=d.priceBase; }
  buildMenuPanel();
  document.getElementById("walkinsToggle").checked = Game.acceptWalkins;
  toast("Loaded. Host + queue + payments + stockouts are active.");
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
