<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Restaurant Tycoon — Single File Modular v18</title>
  <style>
  :root{
    --bg:#0b0d10;
    --border: rgba(255,255,255,0.12);
    --muted: rgba(255,255,255,0.65);
    --text: rgba(255,255,255,0.92);
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: radial-gradient(1200px 700px at 30% 20%, rgba(255,210,91,0.08), transparent 55%),
                radial-gradient(1200px 700px at 70% 10%, rgba(120,198,255,0.06), transparent 55%),
                var(--bg);
    color: var(--text);
  }
  .topbar{
    position: sticky; top:0; z-index:10;
    background: rgba(10,12,16,0.86);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(255,255,255,0.08);
    padding: 10px 12px;
    display:flex;
    gap: 12px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .brand{ display:flex; gap:12px; align-items:center; }
  .logo{
    width:40px; height:40px; border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    background: rgba(255,210,91,0.12);
    border: 1px solid rgba(255,210,91,0.26);
    font-weight: 900;
  }
  h1{ font-size:18px; margin:0; }
  .sub{ font-size:12px; color: var(--muted); margin-top:2px; }
  .muted{ color: var(--muted); font-weight:600; }
  .controls{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  button, select{
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.06);
    color: inherit;
    padding: 10px 12px;
    font-weight: 750;
    cursor:pointer;
  }
  button.primary{
    background: rgba(255,210,91,0.16);
    border-color: rgba(255,210,91,0.30);
  }
  button.danger{
    background: rgba(255,97,97,0.12);
    border-color: rgba(255,97,97,0.25);
  }
  button:disabled{ opacity:0.5; cursor:not-allowed; }
  input[type="range"]{ width: 170px; }

  .wrap{
    display:grid;
    grid-template-columns: 420px 1fr;
    gap: 12px;
    padding: 12px;
    align-items:start;
  }
  .left{ display:flex; flex-direction:column; gap: 12px; }
  .right{ min-width: 0; }

  .card{
    background: rgba(18,24,33,0.90);
    border: 1px solid var(--border);
    border-radius: 16px;
    overflow:hidden;
  }
  .card h2{
    margin:0;
    padding: 12px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom: 1px solid rgba(255,255,255,0.07);
    font-size: 14px;
  }
  .card h2 span{ font-weight: 900; letter-spacing:0.2px; }
  .card .body{ padding: 12px; }
  .small{ font-size: 12px; color: var(--muted); }
  .row{ display:flex; align-items:center; gap:10px; }
  .pill{
    display:inline-flex;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
    font-size: 12px;
    font-weight: 850;
  }

  .canvasWrap{
    background: rgba(18,24,33,0.55);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 16px;
    padding: 10px;
    position:relative;
  }
  canvas{
    width: 100%;
    height: auto;
    border-radius: 12px;
    background: rgba(0,0,0,0.22);
    border: 1px solid rgba(255,255,255,0.10);
    touch-action: none;
  }
  .canvasHelp{
    position:absolute;
    left: 16px;
    top: 16px;
    display:flex;
    gap: 8px;
    flex-wrap:wrap;
    pointer-events:none;
  }

  .toolGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 10px;
  }
  .toolBtn{
    display:flex; justify-content:space-between; align-items:center;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.05);
    cursor:pointer;
    font-weight:800;
    user-select:none;
  }
  .toolBtn.active{
    border-color: rgba(255,210,91,0.38);
    background: rgba(255,210,91,0.10);
  }

  .kv{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px 10px;
    margin-top: 4px;
    align-items:center;
  }
  .kv .k{ font-size: 12px; color: var(--muted); }
  .kv .v{ font-size: 13px; font-weight: 850; }

  .ticketList{ display:flex; flex-direction:column; gap:8px; margin-top:8px; }
  .ticket{
    padding: 10px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.04);
  }
  .ticket .top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .ticket .title{ font-weight: 900; font-size: 13px; }
  .ticket .meta{ font-size: 12px; color: var(--muted); }

  .staffList{ display:flex; flex-direction:column; gap:8px; margin-top:10px; max-height:220px; overflow:auto; padding-right:6px;}
  .staff{
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.04);
    border-radius: 14px;
    padding: 10px 10px;
  }
  .staff .top{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
  .staff .name{ font-weight: 900; }
  .miniBar{ height:6px; border-radius:999px; background: rgba(255,255,255,0.08); overflow:hidden; }
  .miniBar > div{ height:100%; background: rgba(255,210,91,0.55); width:50%; }

  .toast{
    position: fixed;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%);
    background: rgba(20,22,26,0.96);
    border: 1px solid rgba(255,255,255,0.14);
    border-radius: 999px;
    padding: 10px 14px;
    font-weight: 800;
    font-size: 13px;
    opacity:0;
    pointer-events:none;
    transition: opacity 0.2s ease;
    z-index: 50;
  }

  .modal{
    position:fixed; inset:0;
    background:rgba(0,0,0,0.55);
    display:none; align-items:center; justify-content:center;
    padding:18px;
    z-index:60;
  }
  .modal.show{ display:flex; }
  .modalInner{
    max-width:680px;
    width:100%;
    background:rgba(20,22,26,0.98);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:16px;
    padding:16px 16px 14px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.45);
  }

  .tipBubble{
    position:fixed;
    left:0; right:0; bottom:0;
    padding:14px;
    display:none;
    z-index:70;
  }
  .tipBubble.show{ display:block; }
  .tipInner{
    max-width:780px;
    margin:0 auto;
    background:rgba(20,22,26,0.98);
    border:1px solid rgba(255,255,255,0.14);
    border-radius:16px;
    padding:12px 12px 10px;
    box-shadow: 0 -14px 50px rgba(0,0,0,0.5);
  }
  .tipIcon{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:18px; height:18px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.25);
    background:rgba(255,255,255,0.06);
    font-weight:900;
    font-size:12px;
    margin-left:10px;
    cursor:pointer;
    user-select:none;
  }
  .coachGlow{
    outline: 3px solid rgba(255,210,91,0.85);
    outline-offset: 3px;
    border-radius: 12px;
  }

  @media (max-width: 980px){
    .wrap{ grid-template-columns: 1fr; }
    .left{ order: 2; }
    .right{ order: 1; }
    button, select{ padding:10px 12px; font-size:14px; }
    input[type="range"]{ width: 150px; }
  }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo">RT</div>
      <div>
        <h1>Restaurant Tycoon <span class="muted">— Single File Modular v18</span></h1>
        <div class="sub">One file for GitHub. Internally modular (mini module-loader). Tap + drag build. Inspector never loses items.</div>
      </div>
    </div>

    <div class="controls">
      <button class="primary" id="btnStart">Start Service</button>
      <button id="btnPause">Pause</button>
      <button id="btnSpeed">Speed ×1</button>
      <button class="danger" id="btnReset">Reset</button>

      <select id="presetSel" title="Preset">
        <option value="bistro">Bistro</option>
        <option value="cafe">Cafe</option>
        <option value="fine">Fine Dining</option>
      </select>
      <button id="btnApplyPreset">Apply Preset</button>
      <button id="btnFixNext">Fix Next</button>

      <button id="btnTutorial">Tutorial</button>
      <button id="btnHints">Hints: On</button>
      <button id="btnSnap">Snap: On</button>
    </div>
  </header>

  <main class="wrap">
    <section class="right">
      <div class="canvasWrap">
        <canvas id="game" width="900" height="680"></canvas>
        <div class="canvasHelp">
          <span class="pill" id="modePill">BUILD</span>
          <span class="pill" id="bottlePill">Bottleneck: —</span>
          <span class="pill" id="resPill">Reservations: —</span>
          <span class="pill" id="touchPill">Tap: place · Drag: move · Tap item: select</span>
        </div>
      </div>
    </section>

    <aside class="left">
      <div class="card">
        <h2><span>Build Tools</span></h2>
        <div class="body">
          <div class="small">Choose a tool, then tap the canvas to place. Tap an item to select. Drag to move.</div>
          <div class="toolGrid" id="toolGrid"></div>
          <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap;">
            <button id="btnDeleteSel" class="danger">Delete Selected</button>
          </div>
        </div>
      </div>

      <div class="card" id="inspectorCard">
        <h2><span>Inspector</span><span class="pill" id="selPill">None</span></h2>
        <div class="body" id="inspectorBody"></div>
      </div>

      <div class="card">
        <h2><span>Staff</span><span class="pill" id="staffPill">—</span></h2>
        <div class="body">
          <div class="row" style="gap:8px; flex-wrap:wrap;">
            <button id="btnHireCook">Hire Cook</button>
            <button id="btnHireWaiter">Hire Waiter</button>
            <button id="btnHireJanitor">Hire Janitor</button>
            <button id="btnAutoAssign">Auto Assign Stations</button>
          </div>
          <div class="small" style="margin-top:8px;">
            Cooks have <b>skills</b> for PREP/COOK/PASS. Throughput is limited by both <b>stations</b> and <b>staff assigned</b>.
          </div>
          <div id="staffList" class="staffList"></div>
        </div>
      </div>

      <div class="card">
        <h2><span>Live Hints</span><span class="pill" id="hintPill">—</span></h2>
        <div class="body">
          <div id="hintText" class="small" style="line-height:1.35;">Hints will appear here.</div>
          <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:10px;">
            <button id="btnHintPrev">◀</button>
            <button id="btnHintNext">▶</button>
            <button id="btnHintPin">Pin: Off</button>
          </div>
        </div>
      </div>

      <div class="card">
        <h2><span>Service</span><span class="pill" id="svcPill">—</span></h2>
        <div class="body">
          <div class="kv">
            <div class="k">Cash</div><div class="v" id="cashLbl">$—</div>
            <div class="k">Rating</div><div class="v" id="ratingLbl">—</div>
            <div class="k">Cleanliness</div><div class="v" id="cleanLbl">—</div>
            <div class="k">Plates</div><div class="v" id="platesLbl">—</div>
            <div class="k">Profit (Shift)</div><div class="v" id="profitLbl">$—</div>
            <div class="k">Shift Left</div><div class="v" id="shiftLbl">—</div>
          </div>
          <div class="small" style="margin-top:10px;">86: <b id="board86">None</b></div>
        </div>
      </div>

      <div class="card">
        <h2><span>Reservations</span><span class="pill" id="resMiniPill">—</span></h2>
        <div class="body">
          <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:2px;">
            <label class="small">Bookings % <b id="resPctLbl">55</b>%<br>
              <input type="range" id="resPct" min="0" max="90" value="55">
            </label>
            <label class="small">VIP % <b id="vipPctLbl">6</b>%<br>
              <input type="range" id="vipPct" min="0" max="20" value="6">
            </label>
            <label class="small">Overbook % <b id="overbookLbl">10</b>%<br>
              <input type="range" id="overbookPct" min="0" max="30" value="10">
            </label>
          </div>
          <div class="row" style="gap:10px; flex-wrap:wrap; margin-top:10px;">
            <label class="small"><input type="checkbox" id="acceptWalkins" checked> Accept walk-ins</label>
            <label class="small"><input type="checkbox" id="holdTables" checked> Hold tables</label>
            <button id="btnRegenerateRes">Regenerate (today)</button>
          </div>
          <div class="small" style="margin-top:10px;">Upcoming (next 6):</div>
          <div id="resList" class="ticketList"></div>
        </div>
      </div>

    </aside>
  </main>

  <div class="toast" id="toast"></div>

  <div class="modal" id="tutorialModal" aria-hidden="true">
    <div class="modalInner">
      <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
        <h2 style="margin:0;">Tutorial</h2>
        <button id="btnTutClose">Close</button>
      </div>
      <div class="small" id="tutStepMeta" style="margin-top:8px; opacity:0.85;"></div>
      <div id="tutStepTitle" style="font-weight:800; margin-top:8px; font-size:16px;"></div>
      <div id="tutStepBody" class="small" style="margin-top:10px; line-height:1.4;"></div>
      <div class="row" style="justify-content:space-between; gap:10px; margin-top:14px; flex-wrap:wrap;">
        <div class="row" style="gap:8px; flex-wrap:wrap;">
          <button id="btnTutPrev">Back</button>
          <button class="primary" id="btnTutNext">Next</button>
        </div>
        <label class="small" style="display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="tutDontShow">
          Don’t auto-open next time
        </label>
      </div>
    </div>
  </div>

  <div class="tipBubble" id="tipBubble" aria-hidden="true">
    <div class="tipInner">
      <div class="row" style="justify-content:space-between; align-items:center; gap:10px;">
        <b id="tipTitle">Tip</b>
        <button id="btnTipClose">Close</button>
      </div>
      <div id="tipBody" class="small" style="margin-top:8px; line-height:1.4;"></div>
    </div>
  </div>

<script>
/**
 * Restaurant Tycoon — Single File Modular v18
 * One HTML file, but internally modular using a tiny loader:
 *   RT.define(name, deps[], factory) and RT.require(name)
 */
const RT = (() => {
  const defs = Object.create(null);
  const cache = Object.create(null);

  function define(name, deps, factory){
    defs[name] = { deps: deps || [], factory };
  }
  function require(name){
    if(cache[name]) return cache[name];
    const def = defs[name];
    if(!def) throw new Error("Module not found: " + name);
    const args = def.deps.map(require);
    const api = def.factory.apply(null, args) || {};
    cache[name] = api;
    return api;
  }
  return { define, require };
})();

// -------------------- util --------------------
RT.define("util", [], () => {
  const U = {
    clamp:(v,a,b)=>Math.max(a,Math.min(b,v)),
    r:(a,b)=>a+Math.random()*(b-a),
    ri:(a,b)=>Math.floor(a+Math.random()*(b-a+1)),
    uid:(p="ID")=>`${p}${Math.random().toString(16).slice(2,6)}${Date.now().toString(16).slice(-4)}`,
    fmtMoney:(n)=>`$${Math.max(0,n).toFixed(0)}`,
    fmtTime:(sec)=>{
      const s=Math.max(0,Math.floor(sec));
      const m=Math.floor(s/60);
      const r=(s%60).toString().padStart(2,"0");
      return `${m}:${r}`;
    }
  };
  return U;
});

// -------------------- data --------------------
RT.define("data", [], () => {
  const MENU = [
    {id:"burger", name:"Burger", price:24, cost:7, prep:1.0, cook:1.2, pass:0.6, invKey:"beef"},
    {id:"pasta", name:"Pasta", price:28, cost:8, prep:1.1, cook:1.3, pass:0.6, invKey:"pasta"},
    {id:"salad", name:"Salad", price:20, cost:5, prep:1.2, cook:0.2, pass:0.5, invKey:"greens"},
    {id:"fish", name:"Fish", price:34, cost:11, prep:1.0, cook:1.5, pass:0.7, invKey:"fish"},
    {id:"steak", name:"Steak", price:42, cost:14, prep:0.9, cook:1.8, pass:0.7, invKey:"beef"},
    {id:"dessert", name:"Dessert", price:18, cost:4, prep:0.8, cook:0.2, pass:0.7, invKey:"dessert"},
  ];
  const defaultInventory = () => ({ beef: 18, pasta: 18, greens: 18, fish: 14, dessert: 20 });
  const WAGES = { cookPerShift: 120, waiterPerShift: 95, janitorPerShift: 90 };
  const NAMES = ["Ava","Noah","Mia","Oliver","Luca","Sienna","Kai","Amara","Zara","Theo","Ivy","Leo","Aria","Finn","Maya","Jude","Remy","Piper"];
  const TOOL_DEFS = [
    {key:"select", label:"Select/Move", zone:"any"},
    {key:"table2", label:"Table (2)", zone:"dining"},
    {key:"table4", label:"Table (4)", zone:"dining"},
    {key:"prep", label:"Station: PREP", zone:"kitchen"},
    {key:"cook", label:"Station: COOK", zone:"kitchen"},
    {key:"pass", label:"Station: PASS", zone:"kitchen"},
    {key:"dish", label:"Dishwasher", zone:"kitchen"},
    {key:"walkin", label:"Walk-in", zone:"kitchen"},
    {key:"extraCook", label:"Extra cooktop", zone:"kitchen"},
  ];
  const SHIFT_SECONDS = 180;
  return { MENU, defaultInventory, WAGES, NAMES, TOOL_DEFS, SHIFT_SECONDS };
});

// -------------------- storage --------------------
RT.define("storage", [], () => {
  const KEY = "rt_single_modular_v18";
  const tutorialKey = "rt_tutorial_seen_v18";
  const save = (S)=>{ try{ localStorage.setItem(KEY, JSON.stringify(S)); }catch(e){} };
  const load = ()=>{ try{ const s=localStorage.getItem(KEY); return s?JSON.parse(s):null; }catch(e){ return null; } };
  const clear = ()=>{ try{ localStorage.removeItem(KEY); }catch(e){} };
  const tutSeen = ()=>{ try{ return localStorage.getItem(tutorialKey)==="1"; }catch(e){ return false; } };
  const setTutSeen = ()=>{ try{ localStorage.setItem(tutorialKey,"1"); }catch(e){} };
  return { save, load, clear, tutSeen, setTutSeen };
});

// -------------------- staff --------------------
RT.define("staff", ["util","data"], (U, D) => {
  function randSkill(mu=0.6, spread=0.22){
    const v = mu + (Math.random()*2-1)*spread;
    return U.clamp(v, 0.25, 0.95);
  }
  function createCook(){
    const id = "C"+U.uid();
    const name = D.NAMES[Math.floor(Math.random()*D.NAMES.length)] + " " + ["P.","K.","R.","S.","T.","M.","L."][U.ri(0,6)];
    const archetype = Math.random();
    let sPrep = randSkill(0.58,0.25), sCook = randSkill(0.58,0.25), sPass = randSkill(0.52,0.25);
    if(archetype < 0.33){ sCook = randSkill(0.72,0.18); }
    else if(archetype < 0.66){ sPrep = randSkill(0.72,0.18); }
    else { sPass = randSkill(0.68,0.20); }
    return { id, name, wage: D.WAGES.cookPerShift, assign:"FLOAT", skills:{PREP:sPrep, COOK:sCook, PASS:sPass}, fatigue:0 };
  }
  function ensureDefaultCooks(S){
    if(!S.cooks) S.cooks=[];
    if(S.cooks.length===0){
      S.cooks.push(createCook(), createCook(), createCook());
      autoAssignStations(S);
    }
  }
  function autoAssignStations(S){
    for(const c of S.cooks) c.assign="FLOAT";
    const bestFor = (station)=>{
      let best=null, bestScore=-1;
      for(const c of S.cooks){
        if(c.assign!=="FLOAT") continue;
        const sc = c.skills[station] ?? 0.5;
        if(sc > bestScore){ bestScore=sc; best=c; }
      }
      if(best) best.assign = station;
    };
    bestFor("PREP"); bestFor("COOK"); bestFor("PASS");
  }
  function stationStaffProfile(S, station){
    const cooks = S.cooks || [];
    const assigned = cooks.filter(c=>c.assign===station);
    const floats = cooks.filter(c=>c.assign==="FLOAT");
    const floatWeight = 0.6;

    let capacityFloat = assigned.length + floats.length*floatWeight;
    const scramble = (assigned.length===0 && floats.length===0);
    const baseCap = scramble ? 0.75 : 0;
    capacityFloat = Math.max(baseCap, capacityFloat);

    let staffCap = Math.max(1, Math.floor(capacityFloat + 0.5));

    let head=0, speedSum=0;
    for(const c of assigned){
      const s = U.clamp(c.skills[station] ?? 0.55, 0.25, 0.95);
      head += 1.0; speedSum += s;
    }
    for(const c of floats){
      const s = U.clamp(c.skills[station] ?? 0.55, 0.25, 0.95);
      head += floatWeight; speedSum += s*floatWeight;
    }
    const avgSkill = (head>0) ? (speedSum/head) : (scramble ? 0.75 : 0.9);
    const speed = U.clamp(avgSkill / 1.10, 0.65, 1.25);

    return {capacity: staffCap, speed};
  }
  return { createCook, ensureDefaultCooks, autoAssignStations, stationStaffProfile };
});

// -------------------- presets --------------------
RT.define("presets", ["util","data"], (U, D) => {
  function presetLayout(kind){
    const base = {
      diningRect:{x:70,y:70,w:640,h:360},
      kitchenRect:{x:70,y:450,w:640,h:200},
      entry:{x:750,y:120},
      tables:[],
      stations:[],
      equipment:[],
    };
    if(kind==="cafe"){
      base.tables = [
        {id:"T1", x:150,y:120,seats:2},{id:"T2", x:300,y:120,seats:2},{id:"T3", x:450,y:120,seats:2},{id:"T4", x:600,y:120,seats:2},
        {id:"T5", x:220,y:250,seats:4},{id:"T6", x:520,y:250,seats:4},
      ];
      base.stations = [{id:"P1", type:"PREP", x:180,y:525},{id:"C1", type:"COOK", x:360,y:525},{id:"X1", type:"PASS", x:560,y:525}];
      base.equipment = [{id:"W1", type:"WALKIN", x:540, y:585},{id:"D1", type:"DISH", x:330, y:600}];
      return base;
    }
    if(kind==="fine"){
      base.tables = [
        {id:"T1", x:170,y:120,seats:2},{id:"T2", x:360,y:120,seats:2},{id:"T3", x:550,y:120,seats:2},
        {id:"T4", x:240,y:260,seats:4},{id:"T5", x:500,y:260,seats:4},
      ];
      base.stations = [
        {id:"P1", type:"PREP", x:150,y:525},{id:"P2", type:"PREP", x:230,y:525},
        {id:"C1", type:"COOK", x:340,y:525},{id:"C2", type:"COOK", x:430,y:525},
        {id:"X1", type:"PASS", x:560,y:525},
      ];
      base.equipment = [
        {id:"W1", type:"WALKIN", x:540, y:585},
        {id:"D1", type:"DISH", x:300, y:585},
        {id:"D2", type:"DISH", x:370, y:615},
        {id:"E1", type:"EXTRA_COOK", x:460, y:615}
      ];
      return base;
    }
    base.tables = [
      {id:"T1", x:130,y:110,seats:2},{id:"T2", x:270,y:110,seats:2},{id:"T3", x:410,y:110,seats:2},{id:"T4", x:550,y:110,seats:2},
      {id:"T5", x:130,y:250,seats:2},{id:"T6", x:270,y:250,seats:2},{id:"T7", x:410,y:250,seats:2},{id:"T8", x:550,y:250,seats:2},
    ];
    base.stations = [
      {id:"P1", type:"PREP", x:170,y:525},{id:"C1", type:"COOK", x:330,y:525},{id:"C2", type:"COOK", x:430,y:525},{id:"X1", type:"PASS", x:560,y:525},
    ];
    base.equipment = [
      {id:"W1", type:"WALKIN", x:540, y:585},
      {id:"D1", type:"DISH", x:300, y:585},
      {id:"D2", type:"DISH", x:370, y:615},
      {id:"E1", type:"EXTRA_COOK", x:460, y:615}
    ];
    return base;
  }
  function presetEconomy(kind){
    if(kind==="fine"){
      return { cash:520, rating:4.1, cleanliness:0.96, waiters:3, janitors:1,
        resSettings:{ pct:75, vipPct:12, overbookPct:6, acceptWalkins:false, holdTables:true } };
    }
    if(kind==="cafe"){
      return { cash:360, rating:3.4, cleanliness:0.90, waiters:1, janitors:0,
        resSettings:{ pct:20, vipPct:1, overbookPct:15, acceptWalkins:true, holdTables:false } };
    }
    return { cash:420, rating:3.6, cleanliness:0.92, waiters:2, janitors:0,
      resSettings:{ pct:55, vipPct:6, overbookPct:10, acceptWalkins:true, holdTables:true } };
  }
  return { presetLayout, presetEconomy };
});

// -------------------- state --------------------
RT.define("state", ["data","staff","presets"], (D, Staff, Presets) => {
  function createState(){
    const S = {
      version: 18,
      mode: "BUILD",
      running: false,
      paused: false,
      speed: 1,
      snap: true,
      tool: "select",
      layout: Presets.presetLayout("bistro"),
      selected: null,
      drag: null,
      cash: 420,
      rating: 3.6,
      cleanliness: 0.92,
      platesTotal: 24,
      platesClean: 22,
      platesDirty: 2,
      waiters: 2,
      janitors: 0,
      cooks: [],
      menu: D.MENU.map(m=>({ ...m })),
      inv: D.defaultInventory(),
      t: 0,
      guests: [],
      tickets: [],
      actors: [],
      effects: [],
      resSettings: { pct:55, vipPct:6, overbookPct:10, acceptWalkins:true, holdTables:true },
      reservations: [],
      heldTableIds: [],
      resStats: { scheduled:0, seated:0, noShow:0, late:0 },
      lastWorst: { name:"—", score:0 },
      board86: [],
      hints: { enabled:true, pinned:false, idx:0 },
      shift: { total: D.SHIFT_SECONDS, left: D.SHIFT_SECONDS, startCash: 420, profit: 0 }
    };
    Staff.ensureDefaultCooks(S);
    return S;
  }
  function applyPresetToState(S, kind){
    const L = Presets.presetLayout(kind);
    const E = Presets.presetEconomy(kind);
    S.layout = JSON.parse(JSON.stringify(L));
    S.cash = E.cash;
    S.rating = E.rating;
    S.cleanliness = E.cleanliness;
    S.waiters = E.waiters;
    S.janitors = E.janitors;
    S.resSettings = JSON.parse(JSON.stringify(E.resSettings));

    S.mode="BUILD"; S.running=false; S.paused=false; S.speed=1; S.t=0;
    S.guests=[]; S.tickets=[]; S.board86=[];
    S.selected=null; S.drag=null;
    S.heldTableIds=[]; S.reservations=[]; S.resStats={scheduled:0,seated:0,noShow:0,late:0};

    const seats = (S.layout.tables||[]).reduce((a,t)=>a+(t.seats||2),0);
    S.platesTotal = Math.max(18, Math.round(seats*1.5));
    S.platesClean = Math.max(2, S.platesTotal-2);
    S.platesDirty = 2;

    S.shift.total = D.SHIFT_SECONDS;
    S.shift.left = D.SHIFT_SECONDS;
    S.shift.startCash = S.cash;
    S.shift.profit = 0;
  }
  return { createState, applyPresetToState };
});

// -------------------- world (counts + hit) --------------------
RT.define("world", ["util"], (U) => {
  const inRect = (x,y,r)=> (x>=r.x && y>=r.y && x<=r.x+r.w && y<=r.y+r.h);

  function counts(S){
    const c = { PREP:0, COOK:0, PASS:0, DISH:0, WALKIN:0, EXTRA_COOK:0, tables:S.layout.tables.length, seats:0 };
    for(const t of S.layout.tables) c.seats += (t.seats||2);
    for(const st of S.layout.stations) c[st.type] = (c[st.type]||0)+1;
    for(const e of S.layout.equipment) c[e.type] = (c[e.type]||0)+1;
    return c;
  }

  function hitTest(S, x, y){
    for(let i=S.layout.tables.length-1;i>=0;i--){
      const t=S.layout.tables[i];
      if(Math.abs(x-t.x) < 32 && Math.abs(y-t.y) < 26) return { kind:"table", id:t.id };
    }
    for(let i=S.layout.stations.length-1;i>=0;i--){
      const st=S.layout.stations[i];
      if(Math.abs(x-st.x) < 40 && Math.abs(y-st.y) < 26) return { kind:"station", id:st.id };
    }
    for(let i=S.layout.equipment.length-1;i>=0;i--){
      const e=S.layout.equipment[i];
      if(Math.abs(x-e.x) < 36 && Math.abs(y-e.y) < 22) return { kind:"equip", id:e.id };
    }
    return null;
  }

  function findSelectedObj(S){
    if(!S.selected) return null;
    if(S.selected.kind==="table") return S.layout.tables.find(t=>t.id===S.selected.id);
    if(S.selected.kind==="station") return S.layout.stations.find(t=>t.id===S.selected.id);
    if(S.selected.kind==="equip") return S.layout.equipment.find(t=>t.id===S.selected.id);
    return null;
  }

  return { inRect, counts, hitTest, findSelectedObj };
});

// -------------------- build (place/move/delete) --------------------
RT.define("build", ["util","world"], (U, World) => {
  function placeAt(S, x, y, toast){
    const D=S.layout.diningRect, K=S.layout.kitchenRect;
    const tool=S.tool;
    const snap = S.snap;
    const sx = snap ? Math.round(x/10)*10 : x;
    const sy = snap ? Math.round(y/10)*10 : y;

    if(tool==="select") return;

    const needsDining = (tool==="table2"||tool==="table4");
    const needsKitchen = !needsDining;

    if(needsDining && !World.inRect(sx,sy,D)){ toast("Place tables inside DINING."); return; }
    if(needsKitchen && !World.inRect(sx,sy,K)){ toast("Place kitchen items inside KITCHEN."); return; }

    if(tool==="table2"||tool==="table4"){
      const id = `T${S.layout.tables.length+1}`;
      S.layout.tables.push({ id, x:sx, y:sy, seats: tool==="table4"?4:2 });
      S.selected={kind:"table", id};
      toast(`Placed ${id}`);
    }
    if(tool==="prep"||tool==="cook"||tool==="pass"){
      const type = tool==="prep"?"PREP":(tool==="cook"?"COOK":"PASS");
      const prefix = type[0];
      const id = `${prefix}${S.layout.stations.filter(a=>a.type===type).length+1}`;
      S.layout.stations.push({ id, type, x:sx, y:sy });
      S.selected={kind:"station", id};
      toast(`Placed ${type}`);
    }
    if(tool==="dish"||tool==="walkin"||tool==="extraCook"){
      const type = tool==="dish"?"DISH":(tool==="walkin"?"WALKIN":"EXTRA_COOK");
      const prefix = type==="DISH"?"D":(type==="WALKIN"?"W":"E");
      const id = `${prefix}${S.layout.equipment.filter(a=>a.type===type).length+1}`;
      S.layout.equipment.push({ id, type, x:sx, y:sy });
      S.selected={kind:"equip", id};
      toast(`Placed ${type}`);
    }
  }

  function moveSelectedTo(S, x, y){
    if(!S.selected) return;
    const snap=S.snap;
    const sx = snap ? Math.round(x/10)*10 : x;
    const sy = snap ? Math.round(y/10)*10 : y;
    const D=S.layout.diningRect, K=S.layout.kitchenRect;

    const obj = World.findSelectedObj(S);
    if(!obj) return;

    if(S.selected.kind==="table"){
      if(!World.inRect(sx,sy,D)) return;
    }else{
      if(!World.inRect(sx,sy,K)) return;
    }
    obj.x=sx; obj.y=sy;
  }

  function deleteSelected(S){
    if(!S.selected) return false;
    const {kind,id} = S.selected;
    if(kind==="table"){
      const i=S.layout.tables.findIndex(t=>t.id===id);
      if(i>=0) S.layout.tables.splice(i,1);
    }
    if(kind==="station"){
      const i=S.layout.stations.findIndex(t=>t.id===id);
      if(i>=0) S.layout.stations.splice(i,1);
    }
    if(kind==="equip"){
      const i=S.layout.equipment.findIndex(t=>t.id===id);
      if(i>=0) S.layout.equipment.splice(i,1);
    }
    S.selected=null;
    S.heldTableIds = (S.heldTableIds||[]).filter(tid=>tid!==id);
    return true;
  }

  return { placeAt, moveSelectedTo, deleteSelected };
});

// -------------------- reservations --------------------
RT.define("reservations", ["util","world"], (U, World) => {
  function regenerate(S){
    const settings = S.resSettings;
    const baseCount = Math.round((World.counts(S).tables * 0.8) * (settings.pct/100));
    const over = Math.round(baseCount * (settings.overbookPct/100));
    const total = Math.max(0, baseCount + over);
    const out = [];
    for(let i=0;i<Math.min(12,total);i++){
      const timeMin = 15 + i*8 + U.ri(0,6);
      const size = [2,2,2,4,4][U.ri(0,4)];
      const isVip = (Math.random()*100) < settings.vipPct;
      out.push({ id:`R${i+1}`, timeMin, size, isVip, status:"BOOKED" });
    }
    S.reservations = out;
    S.resStats = { scheduled: out.length, seated:0, noShow:0, late:0 };
  }
  return { regenerate };
});

// -------------------- service --------------------
RT.define("service", ["util","data","world","staff","reservations"], (U, D, World, Staff, Res) => {
  function availableTableFor(S, size, allowHeld){
    const candidates = S.layout.tables
      .filter(t => (t.seats||2) >= size)
      .filter(t => !S.guests.some(g=>g.tableId===t.id))
      .filter(t => allowHeld ? true : !(S.heldTableIds||[]).includes(t.id))
      .sort((a,b)=>(a.seats-b.seats));
    return candidates[0] || null;
  }

  function start(S, toast){
    if(S.layout.tables.length===0){ toast("Add tables first."); return false; }
    S.mode="SERVICE";
    S.running=true;
    S.paused=false;
    // spawn tiny moving sprites for staff/guests
    try{ RT.require("actors").spawnStaff(S); }catch(e){}
    S.shift.total = D.SHIFT_SECONDS;
    S.shift.left = D.SHIFT_SECONDS;
    S.shift.startCash = S.cash;
    S.shift.profit = 0;
    if(!S.reservations || !S.reservations.length) Res.regenerate(S);
    toast("Service started.");
    return true;
  }

  function stop(S, toast){
    S.running=false;
    S.paused=false;
    S.mode="BUILD";
    S.guests=[];
    S.tickets=[];
    S.heldTableIds=[];
    toast("Back to Build Mode.");
  }

  function endShift(S, toast){
    const wage = (S.cooks?.length||0)*D.WAGES.cookPerShift + (S.waiters||0)*D.WAGES.waiterPerShift + (S.janitors||0)*D.WAGES.janitorPerShift;
    S.cash = Math.max(0, S.cash - wage);
    S.shift.profit = S.cash - S.shift.startCash;
    toast(`Shift ended. Wages paid: $${wage}.`);
    stop(S, toast);
  }

  function menuPick(S){
    const n = (Math.random()<0.35)?2:1;
    const picks = [];
    for(let i=0;i<n;i++){
      const m = S.menu[U.ri(0,S.menu.length-1)];
      picks.push(m);
    }
    return picks;
  }

  function tick(S, dt, toast){
    S.t += dt;

    S.shift.left -= dt;
    S.shift.profit = S.cash - S.shift.startCash;
    if(S.shift.left <= 0){
      endShift(S, toast);
      return;
    }

    S.heldTableIds = [];
    if(S.resSettings.holdTables){
      for(const r of S.reservations){
        if(r.status!=="BOOKED") continue;
        if(r.timeMin - S.t < 10 && r.timeMin - S.t > -5){
          const t = availableTableFor(S, r.size, true);
          if(t) S.heldTableIds.push(t.id);
        }
      }
    }

    for(const r of S.reservations){
      if(r.status!=="BOOKED") continue;
      if(S.t >= r.timeMin){
        const noShow = Math.random() < 0.10;
        if(noShow){
          r.status="NO_SHOW";
          S.resStats.noShow += 1;
          continue;
        }
        const t = availableTableFor(S, r.size, true);
        if(t){
          r.status="SEATED";
          S.resStats.seated += 1;
          S.guests.push({ id:U.uid("G"), size:r.size, vip:r.isVip, tableId:t.id, phase:"SEATED", orderT:0, eatT:0 });
        }else{
          r.status="BLOWUP";
          S.rating -= r.isVip ? 0.06 : 0.02;
        }
      }
    }

    const demandRate = 0.32;
    const seatFactor = Math.max(0.8, World.counts(S).seats / 16);
    const p = demandRate * seatFactor * dt;
    if(S.resSettings.acceptWalkins){
      if(Math.random() < p){
        const size = (Math.random()<0.7)?2:4;
        const t = availableTableFor(S, size, false);
        if(t){
          S.guests.push({ id:U.uid("G"), size, vip:false, tableId:t.id, phase:"SEATED", orderT:0, eatT:0 });
        }else{
          if(Math.random()<0.25) S.rating -= 0.01;
        }
      }
    }

    const fohCap = Math.max(1, S.waiters) * 2.8;
    for(const g of S.guests){
      if(g.phase==="SEATED"){
        g.orderT += dt;
        const orderDelay = 6.5 + (S.guests.length / fohCap) * 6.0;
        if(g.orderT >= orderDelay){
          g.phase="ORDERED";
          const items = menuPick(S);
          S.tickets.push({
            id: U.uid("T"),
            tableId: g.tableId,
            vip: g.vip,
            created: S.t,
            items: items.map(m=>m.id),
            stage:"PREP",
            p:0
          });
        }
      }
    }

    const outSet = new Set();
    for(const m of S.menu){
      const key = m.invKey;
      if(S.inv[key] <= 0) outSet.add(m.name);
    }
    S.board86 = Array.from(outSet);

    const c = World.counts(S);
    const staffPrep = Staff.stationStaffProfile(S,"PREP");
    const staffCook = Staff.stationStaffProfile(S,"COOK");
    const staffPass = Staff.stationStaffProfile(S,"PASS");

    const prepWorkers = Math.max(1, Math.min(c.PREP, staffPrep.capacity));
    const cookWorkers = Math.max(1, Math.min(c.COOK + c.EXTRA_COOK, staffCook.capacity));
    const passWorkers = Math.max(1, Math.min(c.PASS, staffPass.capacity));

    const prepCap = prepWorkers * staffPrep.speed * 0.9;
    const cookCap = cookWorkers * staffCook.speed * 0.9;
    const passCap = passWorkers * staffPass.speed * 1.1;

    const qPrep = S.tickets.filter(t=>t.stage==="PREP").length;
    const qCook = S.tickets.filter(t=>t.stage==="COOK").length;
    const qPass = S.tickets.filter(t=>t.stage==="PASS").length;

    for(const t of S.tickets){
      const items = t.items.map(id=>S.menu.find(m=>m.id===id)).filter(Boolean);
      const prepNeed = items.reduce((a,m)=>a+m.prep,0);
      const cookNeed = items.reduce((a,m)=>a+m.cook,0);
      const passNeed = items.reduce((a,m)=>a+m.pass,0);

      if(t.stage==="PREP"){
        t.p += (dt / (prepNeed*6.0)) * prepCap;
        if(t.p >= 1){ t.stage="COOK"; t.p=0; }
      }else if(t.stage==="COOK"){
        t.p += (dt / (cookNeed*6.5)) * cookCap;
        if(t.p >= 1){ t.stage="PASS"; t.p=0; }
      }else if(t.stage==="PASS"){
        t.p += (dt / (passNeed*5.0)) * passCap;
        if(t.p >= 1){ t.stage="DONE"; t.p=1; }
      }
    }

    for(const g of S.guests){
      if(g.phase==="ORDERED"){
        const ticket = S.tickets.find(t=>t.tableId===g.tableId && t.stage==="DONE");
        if(ticket){
          const platesNeed = Math.max(1, Math.ceil(g.size/2));
          if(S.platesClean >= platesNeed){
            S.platesClean -= platesNeed;
            S.platesDirty += platesNeed;

            let rev=0, cost=0;
            for(const id of ticket.items){
              const m = S.menu.find(x=>x.id===id);
              if(!m) continue;
              if(S.inv[m.invKey] <= 0){
                S.rating -= 0.02;
                continue;
              }
              S.inv[m.invKey] -= 1;
              rev += m.price;
              cost += m.cost;
            }
            S.cash += Math.max(0, rev - cost);

            g.phase="EATING";
            g.eatT = 0;

            const ti = S.tickets.indexOf(ticket);
            if(ti>=0) S.tickets.splice(ti,1);
          }else{
            if(Math.random()<0.15) S.rating -= 0.02;
          }
        }
      }else if(g.phase==="EATING"){
        g.eatT += dt;
        const eatTime = 14 + U.r(0,6);
        if(g.eatT >= eatTime) g.phase="LEFT";
      }
    }
    S.guests = S.guests.filter(g=>g.phase!=="LEFT");

    const dishwash = Math.max(0, c.DISH);
    const washRate = 0.35 + dishwash * 0.45;
    const washed = Math.min(S.platesDirty, washRate * dt);
    S.platesDirty -= washed;
    S.platesClean = Math.min(S.platesTotal, S.platesClean + washed);

    const dirtyRatio = S.platesDirty / Math.max(1,S.platesTotal);
    S.cleanliness -= dirtyRatio * 0.0025 * dt;
    S.cleanliness += (S.janitors*0.0010) * dt;
    S.cleanliness = U.clamp(S.cleanliness, 0.2, 1.0);

    const waitPressure = (S.guests.length / Math.max(1, fohCap));
    S.rating -= waitPressure * 0.0009 * dt;
    S.rating += 0.00025 * dt;
    S.rating = U.clamp(S.rating, 1.0, 5.0);

    const dishScore = (dirtyRatio*2.2);
    const fohScore = waitPressure;
    const prepScore = (qPrep / Math.max(1, prepCap*3));
    const cookScore = (qCook / Math.max(1, cookCap*3));
    const passScore = (qPass / Math.max(1, passCap*3));
    const arr = [
      {name:"FOH", score:fohScore},
      {name:"DISH PIT", score:dishScore},
      {name:"PREP", score:prepScore},
      {name:"COOK", score:cookScore},
      {name:"PASS", score:passScore},
    ].sort((a,b)=>b.score-a.score);
    S.lastWorst = arr[0] || {name:"—", score:0};
  }

  return { start, stop, tick };
});


// -------------------- actors (tiny moving sprites) --------------------
RT.define("actors", ["util","world"], (U, World) => {
  const ROLE = { COOK:"COOK", WAITER:"WAITER", JANITOR:"JANITOR", GUEST:"GUEST" };

  function spawnStaff(S){
    const K = S.layout.kitchenRect;
    const D = S.layout.diningRect;
    const entry = S.layout.entry;

    S.actors = (S.actors||[]).filter(a=>a.role===ROLE.GUEST);

    // cooks (hang around kitchen stations)
    for(let i=0;i<(S.cooks?.length||0);i++){
      const a = {
        id: U.uid("A"), role: ROLE.COOK, name: (S.cooks[i].name||"Cook"),
        x: U.r(K.x+40, K.x+K.w-40), y: U.r(K.y+30, K.y+K.h-30),
        tx: 0, ty: 0, speed: U.r(52, 68),
        mood: "focused", t: 0
      };
      S.actors.push(a);
    }

    // waiters (bounce between kitchen pass and tables)
    for(let i=0;i<(S.waiters||0);i++){
      const a = {
        id: U.uid("A"), role: ROLE.WAITER, name: "Waiter",
        x: entry.x-30, y: entry.y+U.r(-20,20),
        tx: 0, ty: 0, speed: U.r(86, 106),
        carrying: null, t: 0
      };
      S.actors.push(a);
    }

    // janitors (patrol dining)
    for(let i=0;i<(S.janitors||0);i++){
      const a = {
        id: U.uid("A"), role: ROLE.JANITOR, name: "Janitor",
        x: D.x+U.r(40, D.w-40), y: D.y+U.r(40, D.h-40),
        tx: 0, ty: 0, speed: U.r(70, 90),
        t: 0
      };
      S.actors.push(a);
    }
  }

  function guestActorFor(S, guestId){
    return (S.actors||[]).find(a=>a.role===ROLE.GUEST && a.guestId===guestId) || null;
  }

  function spawnGuestActor(S, g){
    const entry = S.layout.entry;
    const a = {
      id: U.uid("A"),
      role: ROLE.GUEST,
      guestId: g.id,
      x: entry.x+U.r(-8,8),
      y: entry.y+U.r(-8,8),
      tx: entry.x, ty: entry.y,
      speed: U.r(58, 76),
      size: g.size || 2,
      vip: !!g.vip,
      t: 0
    };
    (S.actors||[]).push(a);
    return a;
  }

  function nearest(obj, arr){
    if(!arr || !arr.length) return null;
    let best=null, bd=1e9;
    for(const a of arr){
      const dx=a.x-obj.x, dy=a.y-obj.y;
      const d=dx*dx+dy*dy;
      if(d<bd){ bd=d; best=a; }
    }
    return best;
  }

  function passPoint(S){
    // choose PASS station location if any; else middle of kitchen
    const pass = (S.layout.stations||[]).filter(s=>s.type==="PASS");
    if(pass.length){
      const p = pass[Math.floor(Math.random()*pass.length)];
      return {x:p.x, y:p.y};
    }
    const K=S.layout.kitchenRect;
    return {x:K.x+K.w*0.55, y:K.y+K.h*0.35};
  }

  function pickTablePoint(S, tableId){
    const t = (S.layout.tables||[]).find(x=>x.id===tableId);
    if(!t) return null;
    return {x: t.x + U.r(-10,10), y: t.y + U.r(-12,12)};
  }

  function setTarget(a, p){
    if(!p) return;
    a.tx=p.x; a.ty=p.y;
  }

  function stepTowards(a, dt){
    const dx=a.tx-a.x, dy=a.ty-a.y;
    const d = Math.hypot(dx,dy);
    if(d<1.5) return true;
    const v = (a.speed||80) * dt;
    const s = Math.min(1, v / Math.max(0.001,d));
    a.x += dx*s; a.y += dy*s;
    return false;
  }

  function tick(S, dt){
    if(!S.actors) S.actors=[];
    // ensure guest actors exist
    for(const g of (S.guests||[])){
      if(!guestActorFor(S,g.id)) spawnGuestActor(S,g);
    }
    // remove guest actors whose guest left
    const live = new Set((S.guests||[]).map(g=>g.id));
    S.actors = S.actors.filter(a=>a.role!==ROLE.GUEST || live.has(a.guestId));

    // behavioural targets
    const K = S.layout.kitchenRect;
    const D = S.layout.diningRect;
    const entry = S.layout.entry;

    for(const a of S.actors){
      a.t = (a.t||0) + dt;
      // occasional retarget
      const needNew = (Math.abs(a.tx-a.x)+Math.abs(a.ty-a.y) < 3) || (Math.random()<0.01);

      if(a.role===ROLE.COOK){
        if(needNew){
          // drift between stations (prep/cook/pass)
          const st = (S.layout.stations||[])[Math.floor(Math.random()*(S.layout.stations||[]).length)] || null;
          if(st) setTarget(a, {x: st.x+U.r(-12,12), y: st.y+U.r(-10,10)});
          else setTarget(a, {x: U.r(K.x+40, K.x+K.w-40), y: U.r(K.y+30, K.y+K.h-30)});
        }
      }
      if(a.role===ROLE.JANITOR){
        if(needNew){
          setTarget(a, {x: U.r(D.x+30, D.x+D.w-30), y: U.r(D.y+30, D.y+D.h-30)});
        }
      }
      if(a.role===ROLE.WAITER){
        // If there are tickets DONE, go pick up at PASS then deliver to table.
        const done = (S.tickets||[]).find(t=>t.stage==="DONE");
        if(done && !a.carrying){
          if(needNew) setTarget(a, passPoint(S));
          const arrived = stepTowards(a, dt);
          if(arrived){
            a.carrying = { ticketId: done.id, tableId: done.tableId };
            // remove ticket to simulate delivery being handled (visual); service logic still uses tickets to find DONE
            // so we keep ticket; but mark as "delivering" to avoid multiple waiters
            done._delivering = true;
            setTarget(a, pickTablePoint(S, done.tableId) || {x:entry.x,y:entry.y});
          }
          continue;
        }

        if(a.carrying){
          if(needNew) setTarget(a, pickTablePoint(S, a.carrying.tableId) || {x:entry.x,y:entry.y});
        }else{
          // go to a random occupied table or entry
          if(needNew){
            const g = (S.guests||[])[Math.floor(Math.random()*(S.guests||[]).length)];
            if(g && g.tableId) setTarget(a, pickTablePoint(S,g.tableId));
            else setTarget(a, {x: entry.x-30, y: entry.y+U.r(-30,30)});
          }
        }
      }

      if(a.role===ROLE.GUEST){
        // follow guest phase: from entry -> table -> entry
        const g = (S.guests||[]).find(x=>x.id===a.guestId);
        if(!g){ setTarget(a, {x:entry.x,y:entry.y}); continue; }
        if(g.phase==="SEATED" || g.phase==="ORDERED" || g.phase==="EATING"){
          const p = pickTablePoint(S,g.tableId);
          if(p) setTarget(a, p);
        }else{
          setTarget(a, {x: entry.x+U.r(-8,8), y: entry.y+U.r(-8,8)});
        }
      }

      // movement
      stepTowards(a, dt);

      // waiter drop-off
      if(a.role===ROLE.WAITER && a.carrying){
        const drop = (Math.abs(a.tx-a.x)+Math.abs(a.ty-a.y) < 3);
        if(drop){
          a.carrying = null;
          // return to pass area
          setTarget(a, passPoint(S));
        }
      }
    }
  }

  return { spawnStaff, tick, ROLE };
});
// -------------------- hints --------------------
RT.define("hints", ["world","staff"], (World, Staff) => {
  function build(S){
    const tips = [];
    const c = World.counts(S);
    const dirtyRatio = (S.platesDirty||0) / Math.max(1, (S.platesTotal||1));
    const fohCap = Math.max(1, S.waiters) * 2.8;
    const fohLoad = (S.guests?.length||0) / Math.max(1, fohCap);

    const sp = Staff.stationStaffProfile(S,"PREP");
    const sc = Staff.stationStaffProfile(S,"COOK");
    const sx = Staff.stationStaffProfile(S,"PASS");

    if(S.mode!=="SERVICE"){
      tips.push({pill:"BUILD", text:"<b>Build Mode:</b> Tap to place. Tap item to select. Drag to move. Inspector lists everything you’ve built."});
      if(c.tables < 3) tips.push({pill:"LAYOUT", text:"Add a few <b>tables</b> first."});
      if((c.PREP+c.COOK+c.PASS) < 3) tips.push({pill:"STATIONS", text:"Add <b>PREP</b>, <b>COOK</b>, <b>PASS</b> at minimum."});
      if(c.DISH===0) tips.push({pill:"DISH", text:"Add a <b>Dishwasher</b> to avoid plate-outs."});
      tips.push({pill:"STAFF", text:"Use <b>Auto Assign Stations</b> so your best cooks cover PREP/COOK/PASS."});
    }else{
      tips.push({pill:"SERVICE", text:"Tap <b>Fix Next</b> to jump to the biggest bottleneck and fix it fast."});
      if(S.platesClean <= 2) tips.push({pill:"PLATES", text:"Low <b>clean plates</b>. Add dishwashers or reduce seating pressure."});
      if(dirtyRatio > 0.65) tips.push({pill:"DISH PIT", text:"Dirty plates piling up. More dishwashers (or janitors) helps cleanliness."});
      if(fohLoad > 1.1) tips.push({pill:"FOH", text:"FOH overloaded. Hire waiters or reduce demand (walk-ins/bookings)."});

      if(c.PREP > sp.capacity) tips.push({pill:"PREP STAFF", text:"More PREP stations than staff capacity. Hire cooks or reassign."});
      if((c.COOK+c.EXTRA_COOK) > sc.capacity) tips.push({pill:"COOK STAFF", text:"More COOK stations than staff capacity. Hire cooks or reassign."});
      if(c.PASS > sx.capacity) tips.push({pill:"PASS STAFF", text:"PASS needs a cook assigned to PASS to keep flow stable."});

      if((S.board86||[]).length) tips.push({pill:"86", text:"Items 86’d. Increase inventory (par) or reduce demand."});
    }

    const bottle = S.lastWorst?.name;
    if(bottle && bottle!=="—"){
      tips.push({pill:"BOTTLENECK", text:`<b>Bottleneck: ${bottle}</b> — add capacity there (station + staff) or reduce demand.`});
    }
    return tips;
  }
  return { build };
});

// -------------------- tutorial --------------------
RT.define("tutorial", ["util","storage"], (U, Storage) => {
  const T = {
    step: 0,
    steps: [
      { title:"Welcome", body:"This build is <b>one file</b> but organised internally into modules. The <b>Inspector</b> lists everything so you don’t lose objects.", focus:null },
      { title:"Build Tools", body:"Pick a tool, then tap the canvas to place. Tap an item to select. Drag to move.", focus:"#toolGrid" },
      { title:"Inspector", body:"Tap items in the list to re-select instantly.", focus:"#inspectorCard" },
      { title:"Staff & Skills", body:"Cooks have skills for <b>PREP/COOK/PASS</b>. Capacity is capped by <b>stations</b> AND <b>assigned staff</b>.", focus:"#btnAutoAssign" },
      { title:"Service Shift", body:"Start service to stress-test your build. Shift ends automatically.", focus:"#btnStart" },
    ]
  };

  function open(){ const m = document.getElementById("tutorialModal"); m.classList.add("show"); m.setAttribute("aria-hidden","false"); }
  function close(){ const m = document.getElementById("tutorialModal"); m.classList.remove("show"); m.setAttribute("aria-hidden","true"); document.querySelectorAll(".coachGlow").forEach(n=>n.classList.remove("coachGlow")); }

  function coachFocus(sel){
    document.querySelectorAll(".coachGlow").forEach(n=>n.classList.remove("coachGlow"));
    if(!sel) return;
    const el = document.querySelector(sel);
    if(el){ el.classList.add("coachGlow"); el.scrollIntoView({behavior:"smooth", block:"center"}); }
  }

  function render(){
    const step = T.steps[T.step];
    document.getElementById("tutStepMeta").textContent = `Step ${T.step+1} of ${T.steps.length}`;
    document.getElementById("tutStepTitle").textContent = step.title;
    document.getElementById("tutStepBody").innerHTML = step.body;
    document.getElementById("btnTutPrev").disabled = (T.step===0);
    document.getElementById("btnTutNext").textContent = (T.step===T.steps.length-1) ? "Finish" : "Next";
    coachFocus(step.focus);
  }

  function start(at=0){ T.step = U.clamp(at,0,T.steps.length-1); render(); open(); }
  function next(){
    if(T.step >= T.steps.length-1){ Storage.setTutSeen(); close(); return; }
    T.step += 1; render();
  }
  function prev(){ T.step = Math.max(0, T.step-1); render(); }

  function maybeAuto(){
    const dont = !!document.getElementById("tutDontShow")?.checked;
    if(!Storage.tutSeen() && !dont) start(0);
  }

  return { start, next, prev, close, maybeAuto, coachFocus };
});

// -------------------- tips bubble --------------------
RT.define("tips", [], () => {
  const tipBubble = (show)=>{
    const b = document.getElementById("tipBubble");
    if(!b) return;
    b.classList.toggle("show", !!show);
    b.setAttribute("aria-hidden", show ? "false":"true");
  };
  const showTip = (title, body)=>{
    document.getElementById("tipTitle").textContent = title || "Tip";
    document.getElementById("tipBody").innerHTML = body || "";
    tipBubble(true);
  };
  const close = ()=>tipBubble(false);

  function wireClose(){
    const closeBtn = document.getElementById("btnTipClose");
    if(closeBtn && !closeBtn._wired){
      closeBtn._wired = true;
      closeBtn.addEventListener("click", ()=>tipBubble(false));
      document.addEventListener("click", (e)=>{
        const b = document.getElementById("tipBubble");
        if(!b || !b.classList.contains("show")) return;
        if(e.target.closest && (e.target.closest("#tipBubble") || e.target.closest(".tipIcon"))) return;
        tipBubble(false);
      });
    }
  }

  return { showTip, close, wireClose };
});

// -------------------- renderer --------------------
RT.define("renderer", ["world","util"], (World, U) => {
  // Better graphics: soft tiles, depth, icons, subtle animation (steam), and polished selection.
  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // Cached patterns (created once per canvas)
  let _cache = { w:0, h:0, tile:null, noise:null };

  function makeTilePattern(ctx){
    const p = document.createElement("canvas");
    p.width = 80; p.height = 80;
    const g = p.getContext("2d");

    // base
    const bg = g.createLinearGradient(0,0,80,80);
    bg.addColorStop(0,"rgba(255,255,255,0.035)");
    bg.addColorStop(1,"rgba(255,255,255,0.010)");
    g.fillStyle = bg;
    g.fillRect(0,0,80,80);

    // tiles
    g.strokeStyle = "rgba(255,255,255,0.06)";
    g.lineWidth = 2;
    g.beginPath();
    for(let x=0;x<=80;x+=20){ g.moveTo(x,0); g.lineTo(x,80); }
    for(let y=0;y<=80;y+=20){ g.moveTo(0,y); g.lineTo(80,y); }
    g.stroke();

    // small specks
    for(let i=0;i<90;i++){
      const x = Math.random()*80, y = Math.random()*80;
      g.fillStyle = "rgba(255,255,255,0.05)";
      g.fillRect(x,y,1,1);
    }

    return ctx.createPattern(p,"repeat");
  }

  function makeNoiseOverlay(ctx){
    const n = document.createElement("canvas");
    n.width = 240; n.height = 240;
    const g = n.getContext("2d");
    const img = g.createImageData(n.width,n.height);
    for(let i=0;i<img.data.length;i+=4){
      const v = Math.random()*255;
      img.data[i]=img.data[i+1]=img.data[i+2]=v;
      img.data[i+3]=10; // subtle alpha
    }
    g.putImageData(img,0,0);
    return ctx.createPattern(n,"repeat");
  }

  function ensureCache(ctx){
    const W = ctx.canvas.width, H = ctx.canvas.height;
    if(_cache.w!==W || _cache.h!==H || !_cache.tile){
      _cache = { w:W, h:H, tile: makeTilePattern(ctx), noise: makeNoiseOverlay(ctx) };
    }
  }

  const isSelected = (S, kind, id)=> (S.selected && S.selected.kind===kind && S.selected.id===id);

  function shadow(ctx, y=3, blur=10, a=0.35){
    ctx.shadowColor = `rgba(0,0,0,${a})`;
    ctx.shadowBlur = blur;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = y;
  }

  function zonePanel(ctx, r, label, tint){
    ctx.save();
    // soft panel
    shadow(ctx, 10, 18, 0.35);
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    roundRect(ctx, r.x, r.y, r.w, r.h, 18);
    ctx.fill();
    ctx.shadowColor="transparent";

    // border
    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.lineWidth = 2;
    roundRect(ctx, r.x, r.y, r.w, r.h, 18);
    ctx.stroke();

    // header tag
    const tagW = 110, tagH = 26;
    shadow(ctx, 6, 10, 0.25);
    const grad = ctx.createLinearGradient(r.x, r.y, r.x+tagW, r.y+tagH);
    grad.addColorStop(0, tint);
    grad.addColorStop(1, "rgba(255,255,255,0.06)");
    ctx.fillStyle = grad;
    roundRect(ctx, r.x+10, r.y+10, tagW, tagH, 12);
    ctx.fill();
    ctx.shadowColor="transparent";

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px system-ui";
    ctx.fillText(label, r.x+22, r.y+28);
    ctx.restore();
  }

  function iconFork(ctx,x,y,s,alpha=0.8){
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = alpha;
    ctx.strokeStyle="rgba(255,255,255,0.85)";
    ctx.lineWidth=2;
    ctx.lineCap="round";
    ctx.beginPath();
    // fork
    ctx.moveTo(-s*0.20,-s*0.25); ctx.lineTo(-s*0.20,s*0.25);
    ctx.moveTo(-s*0.32,-s*0.25); ctx.lineTo(-s*0.32,-s*0.05);
    ctx.moveTo(-s*0.24,-s*0.25); ctx.lineTo(-s*0.24,-s*0.05);
    ctx.moveTo(-s*0.16,-s*0.25); ctx.lineTo(-s*0.16,-s*0.05);
    // knife
    ctx.moveTo(s*0.22,-s*0.25); ctx.lineTo(s*0.22,s*0.25);
    ctx.stroke();
    ctx.restore();
  }

  function drawEntry(ctx, x, y){
    ctx.save();
    shadow(ctx, 6, 10, 0.28);
    ctx.fillStyle = "rgba(255,210,91,0.20)";
    ctx.strokeStyle = "rgba(255,210,91,0.65)";
    ctx.lineWidth = 2;
    roundRect(ctx, x-18, y-14, 58, 28, 14);
    ctx.fill(); ctx.stroke();
    ctx.shadowColor="transparent";
    iconFork(ctx, x+6, y, 22, 0.8);
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.font = "12px system-ui";
    ctx.fillText("ENTRY", x+48, y+4);
    ctx.restore();
  }

  function drawTable(ctx, t, selected, held, pulse){
    const w = t.seats===4 ? 62 : 52;
    const h = 44;

    ctx.save();
    ctx.translate(t.x, t.y);

    // selection ring
    if(selected){
      ctx.save();
      ctx.globalAlpha = 0.55 + 0.35*Math.sin(pulse);
      ctx.strokeStyle = "rgba(255,210,91,0.95)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.ellipse(0, 0, w*0.62, h*0.62, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // shadow + top
    shadow(ctx, 8, 14, 0.32);
    const top = ctx.createLinearGradient(-w/2,-h/2,w/2,h/2);
    top.addColorStop(0, held ? "rgba(255,210,91,0.22)" : "rgba(120,198,255,0.16)");
    top.addColorStop(1, "rgba(255,255,255,0.04)");
    ctx.fillStyle = top;

    ctx.strokeStyle = selected ? "rgba(255,210,91,0.95)" : "rgba(255,255,255,0.22)";
    ctx.lineWidth = selected ? 3 : 2;
    roundRect(ctx, -w/2, -h/2, w, h, 14);
    ctx.fill(); ctx.stroke();
    ctx.shadowColor="transparent";

    // chairs (simple dots)
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    const chairs = (t.seats||2);
    const pts = chairs===4 ? [[-w*0.30,-h*0.68],[w*0.30,-h*0.68],[-w*0.30,h*0.68],[w*0.30,h*0.68]]
                           : [[-w*0.24,-h*0.68],[w*0.24,h*0.68]];
    for(const [cx,cy] of pts){
      ctx.beginPath(); ctx.arc(cx,cy,5,0,Math.PI*2); ctx.fill();
    }

    // label
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.font = "12px system-ui";
    ctx.textAlign="center";
    ctx.fillText(t.id, 0, 5);

    if(held){
      ctx.fillStyle="rgba(255,210,91,0.95)";
      ctx.font="10px system-ui";
      ctx.fillText("HELD", 0, 19);
    }
    ctx.restore();
  }

  function stationIcon(ctx, type){
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.88)";
    ctx.lineWidth=2;
    ctx.lineCap="round";
    ctx.lineJoin="round";
    ctx.globalAlpha=0.95;
    ctx.beginPath();
    if(type==="PREP"){
      // knife
      ctx.moveTo(-14,-6); ctx.lineTo(10,10);
      ctx.moveTo(-6,-14); ctx.lineTo(14,6);
    }else if(type==="COOK"){
      // flame
      ctx.moveTo(0,-12);
      ctx.quadraticCurveTo(10,-2,0,12);
      ctx.quadraticCurveTo(-10,-2,0,-12);
    }else{
      // pass bell
      ctx.arc(0,2,10,Math.PI,0);
      ctx.moveTo(-10,2); ctx.lineTo(10,2);
      ctx.moveTo(0,-12); ctx.lineTo(0,-14);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawStation(ctx, st, selected, pulse){
    const w=78,h=42;
    ctx.save();
    ctx.translate(st.x, st.y);

    // selection ring
    if(selected){
      ctx.save();
      ctx.globalAlpha = 0.55 + 0.35*Math.sin(pulse);
      ctx.strokeStyle = "rgba(255,210,91,0.95)";
      ctx.lineWidth = 5;
      roundRect(ctx, -w/2-6, -h/2-6, w+12, h+12, 16);
      ctx.stroke();
      ctx.restore();
    }

    shadow(ctx, 8, 14, 0.30);
    const base = ctx.createLinearGradient(-w/2,-h/2,w/2,h/2);
    const tint = st.type==="COOK" ? "rgba(255,97,97,0.18)" : (st.type==="PREP" ? "rgba(120,198,255,0.18)" : "rgba(185,255,161,0.14)");
    base.addColorStop(0, tint);
    base.addColorStop(1, "rgba(255,255,255,0.04)");
    ctx.fillStyle = base;

    ctx.strokeStyle = selected ? "rgba(255,210,91,0.95)" : "rgba(255,255,255,0.22)";
    ctx.lineWidth = selected ? 3 : 2;
    roundRect(ctx, -w/2, -h/2, w, h, 14);
    ctx.fill(); ctx.stroke();
    ctx.shadowColor="transparent";

    // icon
    stationIcon(ctx, st.type);

    // label
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.font="12px system-ui";
    ctx.textAlign="center";
    ctx.fillText(st.type, 0, 6);
    ctx.font="10px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.60)";
    ctx.fillText(st.id, 0, 20);

    ctx.restore();
  }

  function drawEquip(ctx, e, selected, pulse){
    const w=64,h=36;
    ctx.save();
    ctx.translate(e.x, e.y);

    if(selected){
      ctx.save();
      ctx.globalAlpha = 0.55 + 0.35*Math.sin(pulse);
      ctx.strokeStyle = "rgba(255,210,91,0.95)";
      ctx.lineWidth = 5;
      roundRect(ctx, -w/2-6, -h/2-6, w+12, h+12, 14);
      ctx.stroke();
      ctx.restore();
    }

    shadow(ctx, 8, 14, 0.30);
    const base = ctx.createLinearGradient(-w/2,-h/2,w/2,h/2);
    base.addColorStop(0,"rgba(255,255,255,0.09)");
    base.addColorStop(1,"rgba(255,255,255,0.03)");
    ctx.fillStyle=base;

    ctx.strokeStyle= selected ? "rgba(255,210,91,0.95)" : "rgba(255,255,255,0.22)";
    ctx.lineWidth = selected ? 3 : 2;
    roundRect(ctx, -w/2, -h/2, w, h, 12);
    ctx.fill(); ctx.stroke();
    ctx.shadowColor="transparent";

    // tiny icon
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.82)";
    ctx.lineWidth=2;
    ctx.beginPath();
    if(e.type==="DISH"){
      ctx.arc(0,2,10,0,Math.PI*2);
      ctx.moveTo(-6,-6); ctx.lineTo(6,10);
    }else if(e.type==="WALKIN"){
      roundRect(ctx, -12,-10,24,22,6);
      ctx.moveTo(0,-10); ctx.lineTo(0,12);
    }else{
      ctx.moveTo(-10,8); ctx.lineTo(10,8);
      ctx.moveTo(-8,2); ctx.lineTo(8,2);
      ctx.moveTo(-6,-4); ctx.lineTo(6,-4);
    }
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle="rgba(255,255,255,0.86)";
    ctx.font="10px system-ui";
    ctx.textAlign="center";
    const name = e.type==="DISH"?"DISH":(e.type==="WALKIN"?"WALK-IN":(e.type==="EXTRA_COOK"?"COOKTOP":"EQUIP"));
    ctx.fillText(name, 0, 16);

    ctx.restore();
  }

  function drawSteam(ctx, x, y, t){
    // subtle animated steam above COOK stations
    ctx.save();
    ctx.translate(x,y);
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle="rgba(255,255,255,0.75)";
    ctx.lineWidth=2;
    for(let i=0;i<3;i++){
      const phase = t*1.2 + i*1.3;
      const ox = Math.sin(phase)*6 + (i-1)*8;
      const oy = -28 - (phase*10 % 22);
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.quadraticCurveTo(ox+6, oy+8, ox, oy+16);
      ctx.quadraticCurveTo(ox-6, oy+22, ox, oy+30);
      ctx.stroke();
    }
    ctx.restore();
  }

  function draw(ctx, S){
    ensureCache(ctx);

    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.clearRect(0,0,W,H);

    // background gradient
    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0,"rgba(255,255,255,0.03)");
    bg.addColorStop(1,"rgba(0,0,0,0.08)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);

    // tiles
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = _cache.tile;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // noise overlay
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = _cache.noise;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // subtle vignette
    ctx.save();
    const v = ctx.createRadialGradient(W*0.5,H*0.35, 20, W*0.5,H*0.35, Math.max(W,H)*0.75);
    v.addColorStop(0,"rgba(0,0,0,0.0)");
    v.addColorStop(1,"rgba(0,0,0,0.30)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    const D = S.layout.diningRect, K = S.layout.kitchenRect;
    zonePanel(ctx, D, "DINING", "rgba(120,198,255,0.22)");
    zonePanel(ctx, K, "KITCHEN", "rgba(255,97,97,0.18)");

    // entry
    drawEntry(ctx, S.layout.entry.x, S.layout.entry.y);

    // pulse timer for selection
    const pulse = (S.t || 0) * 2.2;

    // draw objects
    for(const t of S.layout.tables){
      drawTable(ctx, t, isSelected(S,"table",t.id), (S.heldTableIds||[]).includes(t.id), pulse);
    }
    for(const st of S.layout.stations){
      drawStation(ctx, st, isSelected(S,"station",st.id), pulse);
      if(S.mode==="SERVICE" && st.type==="COOK") drawSteam(ctx, st.x, st.y, S.t||0);
    }
    for(const e of S.layout.equipment){
      drawEquip(ctx, e, isSelected(S,"equip",e.id), pulse);
    }

    // guests markers
    if(S.mode==="SERVICE"){
      for(const g of S.guests){
        if(!g.tableId) continue;
        const t = S.layout.tables.find(x=>x.id===g.tableId);
        if(!t) continue;
        ctx.save();
        ctx.fillStyle = g.vip ? "rgba(255,210,91,0.90)" : "rgba(120,198,255,0.82)";
        ctx.font = "11px system-ui";
        ctx.fillText(`${g.size}p`, t.x-14, t.y-22);
        ctx.restore();
      }
    }

    
    // actors (staff + guests) sprites
    if(S.actors && S.actors.length){
      for(const a of S.actors){
        ctx.save();
        const isGuest = a.role==="GUEST";
        const r = isGuest ? (a.vip ? 7 : 6) : (a.role==="WAITER" ? 6 : 6);
        // colors by role (no explicit style names; just rgba)
        let fill = "rgba(255,255,255,0.80)";
        let stroke = "rgba(0,0,0,0.35)";
        if(a.role==="COOK") fill = "rgba(255,97,97,0.85)";
        if(a.role==="WAITER") fill = "rgba(120,198,255,0.85)";
        if(a.role==="JANITOR") fill = "rgba(185,255,161,0.80)";
        if(a.role==="GUEST") fill = a.vip ? "rgba(255,210,91,0.92)" : "rgba(255,255,255,0.78)";

        // tiny shadow
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(0,0,0,0.32)";
        ctx.beginPath();
        ctx.ellipse(a.x, a.y + (isGuest?7:6), r*0.95, r*0.55, 0, 0, Math.PI*2);
        ctx.fill();

        // body
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(a.x, a.y, r, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();

        // waiter carrying
        if(a.role==="WAITER" && a.carrying){
          ctx.fillStyle = "rgba(255,210,91,0.90)";
          ctx.beginPath();
          ctx.arc(a.x + 9, a.y - 7, 3, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }
    }
// selection footer
    if(S.selected){
      const obj = World.findSelectedObj(S);
      if(obj){
        ctx.save();
        shadow(ctx, 8, 18, 0.35);
        ctx.fillStyle="rgba(20,22,26,0.75)";
        roundRect(ctx, 12, H-46, 420, 32, 14);
        ctx.fill();
        ctx.shadowColor="transparent";
        ctx.fillStyle="rgba(255,255,255,0.92)";
        ctx.font="12px system-ui";
        ctx.fillText(`Selected: ${S.selected.kind.toUpperCase()} · ${obj.id || ""} ${obj.type?("· "+obj.type):""} ${obj.seats?("· "+obj.seats+" seats"):""}`, 24, H-26);
        ctx.restore();
      }
    }
  }

  return { draw };
});

// -------------------- UI --------------------
RT.define("ui", ["util","data","storage","world","build","state","staff","reservations","service","hints","tutorial","tips","renderer"],
(U, D, Storage, World, Build, State, Staff, Res, Service, Hints, Tutorial, Tips, Renderer) => {

  function qs(id){ return document.getElementById(id); }

  const ui = {
    canvas: qs("game"),
    ctx: null,
    toastEl: qs("toast"),
    toolGrid: qs("toolGrid"),
    inspectorBody: qs("inspectorBody"),
    selPill: qs("selPill"),
    modePill: qs("modePill"),
    bottlePill: qs("bottlePill"),
    resPill: qs("resPill"),
    resMiniPill: qs("resMiniPill"),
    hintPill: qs("hintPill"),
    hintText: qs("hintText"),
    resList: qs("resList"),
    cashLbl: qs("cashLbl"),
    ratingLbl: qs("ratingLbl"),
    cleanLbl: qs("cleanLbl"),
    platesLbl: qs("platesLbl"),
    profitLbl: qs("profitLbl"),
    shiftLbl: qs("shiftLbl"),
    board86: qs("board86"),
    svcPill: qs("svcPill"),
    staffPill: qs("staffPill"),
    staffList: qs("staffList"),

    btnStart: qs("btnStart"),
    btnPause: qs("btnPause"),
    btnSpeed: qs("btnSpeed"),
    btnReset: qs("btnReset"),
    presetSel: qs("presetSel"),
    btnApplyPreset: qs("btnApplyPreset"),
    btnFixNext: qs("btnFixNext"),
    btnTutorial: qs("btnTutorial"),
    btnHints: qs("btnHints"),
    btnSnap: qs("btnSnap"),
    btnDeleteSel: qs("btnDeleteSel"),

    btnHireCook: qs("btnHireCook"),
    btnHireWaiter: qs("btnHireWaiter"),
    btnHireJanitor: qs("btnHireJanitor"),
    btnAutoAssign: qs("btnAutoAssign"),

    btnHintPrev: qs("btnHintPrev"),
    btnHintNext: qs("btnHintNext"),
    btnHintPin: qs("btnHintPin"),

    resPct: qs("resPct"),
    vipPct: qs("vipPct"),
    overbookPct: qs("overbookPct"),
    resPctLbl: qs("resPctLbl"),
    vipPctLbl: qs("vipPctLbl"),
    overbookLbl: qs("overbookLbl"),
    acceptWalkins: qs("acceptWalkins"),
    holdTables: qs("holdTables"),
    btnRegenerateRes: qs("btnRegenerateRes"),

    toast:(msg)=>{
      ui.toastEl.textContent = msg;
      ui.toastEl.style.opacity = 1;
      clearTimeout(ui._toastT);
      ui._toastT = setTimeout(()=>ui.toastEl.style.opacity=0, 1200);
    }
  };
  ui.ctx = ui.canvas.getContext("2d");

  function buildToolsUI(S){
    const grid = ui.toolGrid;
    grid.innerHTML = "";
    for(const t of D.TOOL_DEFS){
      const b = document.createElement("div");
      b.className = "toolBtn" + (S.tool===t.key ? " active":"");
      b.innerHTML = `<span>${t.label}</span><span class="small">${t.zone}</span>`;
      b.addEventListener("click", ()=>{
        S.tool = t.key;
        buildToolsUI(S);
        ui.toast(`Tool: ${t.label}`);
      });
      grid.appendChild(b);
    }
  }

  function itemRow(kind,id,label,selected){
    const active = selected && selected.kind===kind && selected.id===id;
    return `<div class="ticket" style="cursor:pointer; ${active?'border-color: rgba(255,210,91,0.35); background: rgba(255,210,91,0.07);':''}" data-sel-kind="${kind}" data-sel-id="${id}">
      <div class="top">
        <div class="title">${label}</div>
        <div class="meta">${kind.toUpperCase()} · <b>${id}</b></div>
      </div>
    </div>`;
  }

  function renderInspector(S){
    ui.selPill.textContent = S.selected ? `${S.selected.kind.toUpperCase()} ${S.selected.id}` : "None";
    const c = World.counts(S);
    const selObj = World.findSelectedObj(S);

    const sp = Staff.stationStaffProfile(S,"PREP"), sc = Staff.stationStaffProfile(S,"COOK"), sx = Staff.stationStaffProfile(S,"PASS");

    const lines = [];
    lines.push(`<div class="small">Totals: <b>${c.tables}</b> tables · <b>${c.seats}</b> seats · PREP <b>${c.PREP}</b> · COOK <b>${c.COOK}</b> · PASS <b>${c.PASS}</b> · DISH <b>${c.DISH}</b></div>`);
    lines.push(`<div class="row" style="gap:8px; flex-wrap:wrap; margin-top:10px;">
      <span class="pill">PREP ${Math.min(c.PREP, sp.capacity)}× @ ${sp.speed.toFixed(2)}</span>
      <span class="pill">COOK ${Math.min(c.COOK+c.EXTRA_COOK, sc.capacity)}× @ ${sc.speed.toFixed(2)}</span>
      <span class="pill">PASS ${Math.min(c.PASS, sx.capacity)}× @ ${sx.speed.toFixed(2)}</span>
    </div>`);

    if(selObj){
      lines.push(`<hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:12px 0;">`);
      lines.push(`<div style="font-weight:900;">Selected</div>`);
      lines.push(`<div class="small">ID: <b>${selObj.id}</b> ${selObj.type?`· Type: <b>${selObj.type}</b>`:""}</div>`);
      lines.push(`<div class="small">Pos: <b>${Math.round(selObj.x)},${Math.round(selObj.y)}</b> ${S.snap?"· Snap ON":""}</div>`);
      if(S.selected.kind==="table"){
        lines.push(`<div class="row" style="margin-top:10px; gap:8px;">
          <button id="btnSeatsMinus">Seats −</button>
          <span class="pill">Seats: ${selObj.seats}</span>
          <button id="btnSeatsPlus">Seats +</button>
        </div>`);
        lines.push(`<div class="small" style="margin-top:8px;">Tip: 4-seaters raise revenue but increase plate demand.</div>`);
      }
    }else{
      lines.push(`<div class="small" style="margin-top:10px;">Tap any item on the canvas to select it.</div>`);
    }

    lines.push(`<hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:12px 0;">`);
    lines.push(`<div style="font-weight:900;">Everything you built</div>`);
    lines.push(`<div class="small">Tap an item below to jump-select it.</div>`);
    lines.push(`<div class="ticketList" style="margin-top:10px;">`);
    for(const t of S.layout.tables){ lines.push(itemRow("table", t.id, `Table (${t.seats})`, S.selected)); }
    for(const st of S.layout.stations){ lines.push(itemRow("station", st.id, st.type, S.selected)); }
    for(const e of S.layout.equipment){
      const name = e.type==="DISH"?"Dishwasher":(e.type==="WALKIN"?"Walk-in":(e.type==="EXTRA_COOK"?"Extra cooktop":"Equip"));
      lines.push(itemRow("equip", e.id, name, S.selected));
    }
    lines.push(`</div>`);
    ui.inspectorBody.innerHTML = lines.join("");

    const bm = document.getElementById("btnSeatsMinus");
    const bp = document.getElementById("btnSeatsPlus");
    if(bm){
      bm.onclick = ()=>{
        const t = World.findSelectedObj(S);
        if(t && t.seats){ t.seats = Math.max(2, t.seats-2); }
      };
    }
    if(bp){
      bp.onclick = ()=>{
        const t = World.findSelectedObj(S);
        if(t && t.seats){ t.seats = Math.min(8, t.seats+2); }
      };
    }

    document.querySelectorAll("[data-sel-kind]").forEach(el=>{
      el.addEventListener("click", ()=>{
        S.selected = { kind: el.dataset.selKind, id: el.dataset.selId };
      });
    });
  }

  function renderStaff(S){
    const cooks = S.cooks || [];
    ui.staffPill.textContent = `${cooks.length} cooks · ${S.waiters||0} waiters · ${S.janitors||0} janitors`;
    ui.staffList.innerHTML = "";
    for(const c of cooks){
      const el = document.createElement("div");
      el.className = "staff";
      const bar = (v)=>`<div class="miniBar"><div style="width:${Math.round(v*100)}%"></div></div>`;
      el.innerHTML = `
        <div class="top">
          <div class="name">${c.name}</div>
          <div class="meta small">${c.assign}</div>
        </div>
        <div class="small" style="margin-top:8px;">PREP ${bar(c.skills.PREP)} COOK ${bar(c.skills.COOK)} PASS ${bar(c.skills.PASS)}</div>
        <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:8px;">
          <button data-assign="${c.id}" data-st="PREP">PREP</button>
          <button data-assign="${c.id}" data-st="COOK">COOK</button>
          <button data-assign="${c.id}" data-st="PASS">PASS</button>
          <button data-assign="${c.id}" data-st="FLOAT">FLOAT</button>
        </div>
      `;
      ui.staffList.appendChild(el);
    }
    ui.staffList.querySelectorAll("[data-assign]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.dataset.assign;
        const st = btn.dataset.st;
        const c = cooks.find(x=>x.id===id);
        if(c){ c.assign = st; }
      });
    });
  }

  function renderReservations(S){
    ui.resMiniPill.textContent = `${S.reservations.length} bookings`;
    ui.resList.innerHTML = "";
    for(const r of S.reservations.slice(0,6)){
      const el = document.createElement("div");
      el.className = "ticket";
      const eta = Math.max(0, Math.round(r.timeMin - S.t));
      el.innerHTML = `<div class="top">
        <div class="title">${r.isVip?"VIP ":""}Booking ${r.id} · ${r.size}p</div>
        <div class="meta">${r.status} · ${eta}s</div>
      </div>`;
      ui.resList.appendChild(el);
    }
  }

  function updateTopBadges(S){
    ui.modePill.textContent = S.mode;
    ui.bottlePill.textContent = (S.lastWorst?.name==="—") ? "Bottleneck: —" : `Bottleneck: ${S.lastWorst.name} (${S.lastWorst.score.toFixed(1)}×)`;
    ui.resPill.textContent = `Bookings ${S.resSettings.pct}% · VIP ${S.resSettings.vipPct}%`;
  }

  function updateServiceKPIs(S){
    ui.cashLbl.textContent = U.fmtMoney(S.cash);
    ui.ratingLbl.textContent = S.rating.toFixed(2);
    ui.cleanLbl.textContent = `${Math.round(S.cleanliness*100)}%`;
    ui.platesLbl.textContent = `${Math.round(S.platesClean)}/${S.platesTotal} clean`;
    ui.profitLbl.textContent = U.fmtMoney(S.shift?.profit ?? 0);
    ui.shiftLbl.textContent = (S.mode==="SERVICE" && S.shift) ? U.fmtTime(S.shift.left) : "—";
    ui.board86.textContent = (S.board86?.length ? S.board86.join(", ") : "None");
    ui.svcPill.textContent = S.mode==="SERVICE" ? `${S.guests.length} parties · ${S.tickets.length} tickets` : "Build then run service";
    ui.btnStart.textContent = (S.mode==="SERVICE") ? "Stop Service" : "Start Service";
    ui.btnPause.textContent = S.paused ? "Resume" : "Pause";
    ui.btnSpeed.textContent = `Speed ×${S.speed}`;
    ui.btnHints.textContent = `Hints: ${S.hints.enabled?"On":"Off"}`;
    ui.btnSnap.textContent = `Snap: ${S.snap?"On":"Off"}`;

    ui.resPct.value = S.resSettings.pct; ui.resPctLbl.textContent = S.resSettings.pct;
    ui.vipPct.value = S.resSettings.vipPct; ui.vipPctLbl.textContent = S.resSettings.vipPct;
    ui.overbookPct.value = S.resSettings.overbookPct; ui.overbookLbl.textContent = S.resSettings.overbookPct;
    ui.acceptWalkins.checked = !!S.resSettings.acceptWalkins;
    ui.holdTables.checked = !!S.resSettings.holdTables;
  }

  function renderHintsBox(S){
    if(!S.hints.enabled){
      ui.hintPill.textContent = "Off";
      ui.hintText.innerHTML = "Hints are off. Tap <b>Hints</b> to re-enable.";
      return;
    }
    const list = Hints.build(S);
    if(!list.length){
      ui.hintPill.textContent = "—";
      ui.hintText.textContent = "No hints.";
      return;
    }
    if(S.hints.idx >= list.length) S.hints.idx = 0;
    const h = list[S.hints.idx];
    ui.hintPill.textContent = h.pill;
    ui.hintText.innerHTML = h.text;
  }

  function nextHint(S){
    const list = Hints.build(S);
    S.hints.idx = (S.hints.idx+1) % Math.max(1,list.length);
  }
  function prevHint(S){
    const list = Hints.build(S);
    S.hints.idx = (S.hints.idx-1 + list.length) % Math.max(1,list.length);
  }

  function fixNext(S){
    const w = S.lastWorst || {name:"—", score:0};
    const map = {
      "FOH": { sel:"#btnHireWaiter", title:"Fix FOH", body:"FOH is bottlenecking. Hire waiters or reduce demand (walk-ins/bookings)." },
      "DISH PIT": { sel:"#toolGrid", title:"Fix Dishpit", body:"Dishpit is bottlenecking. Add dishwashers in the kitchen area." },
      "PREP": { sel:"#btnHireCook", title:"Fix PREP", body:"Add PREP stations and assign/hire cooks to PREP." },
      "COOK": { sel:"#btnHireCook", title:"Fix COOK", body:"Add COOK stations/extra cooktop and assign/hire cooks to COOK." },
      "PASS": { sel:"#btnHireCook", title:"Fix PASS", body:"Add a PASS station and assign a strong cook to PASS." },
    };
    const t = map[w.name] || (S.mode==="SERVICE"
      ? { sel:"#bottlePill", title:"Fix Next", body:"Start with the Bottleneck. Add capacity there (stations + staff) or reduce demand." }
      : { sel:"#toolGrid", title:"Fix Next", body:"You’re in Build Mode. Place missing stations/tables, then start service." });
    Tutorial.coachFocus(t.sel);
    Tips.showTip(t.title, t.body);
  }

  function wireTooltips(){
    const map = {
      "#btnStart": { title:"Start/Stop Service", body:"Start service to stress-test your build. A shift ends automatically and wages are paid." },
      "#btnFixNext": { title:"Fix Next", body:"Jumps you to the biggest bottleneck and tells you what to do next." },
      "#toolGrid": { title:"Build Tools", body:"Choose a tool then tap canvas to place. Tap item to select; drag to move." },
      "#inspectorCard": { title:"Inspector", body:"Everything you built is listed here. Tap any item to re-select instantly." },
      "#presetSel": { title:"Presets", body:"Cafe / Bistro / Fine Dining load different starting floorplans and service pressure." },
      "#btnAutoAssign": { title:"Auto Assign", body:"Automatically assigns your best cooks to PREP / COOK / PASS." },
    };
    for(const sel of Object.keys(map)){
      const el = document.querySelector(sel);
      if(!el) continue;
      if(el._tipWired) continue;
      el._tipWired = true;
      const icon = document.createElement("span");
      icon.className = "tipIcon";
      icon.textContent = "?";
      icon.addEventListener("click", ()=>Tips.showTip(map[sel].title, map[sel].body));
      el.insertAdjacentElement("afterend", icon);
    }
    Tips.wireClose();
  }

  function wire(S){
    buildToolsUI(S);
    wireTooltips();

    // Top controls
    ui.btnStart.onclick = ()=>{
      if(S.mode==="SERVICE") Service.stop(S, ui.toast);
      else Service.start(S, ui.toast);
      Storage.save(S);
    };
    ui.btnPause.onclick = ()=>{ S.paused = !S.paused; };
    ui.btnSpeed.onclick = ()=>{ S.speed = (S.speed===1)?2:(S.speed===2?3:1); };
    ui.btnReset.onclick = ()=>{
      Storage.clear();
      const fresh = State.createState();
      Object.keys(S).forEach(k=>delete S[k]);
      Object.assign(S, fresh);
      buildToolsUI(S);
      ui.toast("Reset complete.");
    };
    ui.btnApplyPreset.onclick = ()=>{
      State.applyPresetToState(S, ui.presetSel.value);
      Staff.ensureDefaultCooks(S);
      Staff.autoAssignStations(S);
      Res.regenerate(S);
      buildToolsUI(S);
      ui.toast(`Preset applied: ${ui.presetSel.value}`);
      Storage.save(S);
    };
    ui.btnFixNext.onclick = ()=>fixNext(S);
    ui.btnTutorial.onclick = ()=>Tutorial.start(0);
    ui.btnHints.onclick = ()=>{ S.hints.enabled = !S.hints.enabled; };
    ui.btnSnap.onclick = ()=>{ S.snap = !S.snap; };

    ui.btnDeleteSel.onclick = ()=>{ if(Build.deleteSelected(S)){ ui.toast("Deleted."); Storage.save(S); } };

    ui.btnHireCook.onclick = ()=>{ S.cooks.push(Staff.createCook()); Staff.autoAssignStations(S); ui.toast("Hired a cook."); if(S.mode==="SERVICE"){ try{ RT.require("actors").spawnStaff(S); }catch(e){} } Storage.save(S); };
    ui.btnHireWaiter.onclick = ()=>{ S.waiters += 1; ui.toast("Hired a waiter."); if(S.mode==="SERVICE"){ try{ RT.require("actors").spawnStaff(S); }catch(e){} } Storage.save(S); };
    ui.btnHireJanitor.onclick = ()=>{ S.janitors += 1; ui.toast("Hired a janitor."); if(S.mode==="SERVICE"){ try{ RT.require("actors").spawnStaff(S); }catch(e){} } Storage.save(S); };
    ui.btnAutoAssign.onclick = ()=>{ Staff.autoAssignStations(S); ui.toast("Auto assigned stations."); Storage.save(S); };

    ui.btnHintNext.onclick = ()=>nextHint(S);
    ui.btnHintPrev.onclick = ()=>prevHint(S);
    ui.btnHintPin.onclick = ()=>{
      S.hints.pinned = !S.hints.pinned;
      ui.btnHintPin.textContent = `Pin: ${S.hints.pinned ? "On":"Off"}`;
    };

    const syncRes = ()=>{
      S.resSettings.pct = parseInt(ui.resPct.value,10);
      S.resSettings.vipPct = parseInt(ui.vipPct.value,10);
      S.resSettings.overbookPct = parseInt(ui.overbookPct.value,10);
      S.resSettings.acceptWalkins = ui.acceptWalkins.checked;
      S.resSettings.holdTables = ui.holdTables.checked;
    };
    ui.resPct.oninput = ()=>syncRes();
    ui.vipPct.oninput = ()=>syncRes();
    ui.overbookPct.oninput = ()=>syncRes();
    ui.acceptWalkins.onchange = ()=>syncRes();
    ui.holdTables.onchange = ()=>syncRes();
    ui.btnRegenerateRes.onclick = ()=>{ syncRes(); Res.regenerate(S); ui.toast("Bookings regenerated."); Storage.save(S); };

    // Tutorial modal wiring
    document.getElementById("btnTutClose").onclick = Tutorial.close;
    document.getElementById("btnTutNext").onclick = Tutorial.next;
    document.getElementById("btnTutPrev").onclick = Tutorial.prev;
    document.getElementById("tutorialModal").addEventListener("click", (e)=>{ if(e.target.id==="tutorialModal") Tutorial.close(); });

    // Canvas pointer interactions
    const canvas = ui.canvas;
    const rect = ()=>canvas.getBoundingClientRect();
    const toCanvas = (clientX, clientY)=>{
      const r = rect();
      const x = (clientX - r.left) * (canvas.width / r.width);
      const y = (clientY - r.top) * (canvas.height / r.height);
      return {x,y};
    };

    let dragging=false;
    canvas.addEventListener("pointerdown", (e)=>{
      canvas.setPointerCapture(e.pointerId);
      const p = toCanvas(e.clientX, e.clientY);
      const hit = World.hitTest(S, p.x, p.y);
      if(hit){
        S.selected = hit;
        dragging = true;
        const obj = World.findSelectedObj(S);
        if(obj){
          S.drag = { offX: p.x - obj.x, offY: p.y - obj.y };
        }
        return;
      }
      Build.placeAt(S, p.x, p.y, ui.toast);
      Storage.save(S);
    });
    canvas.addEventListener("pointermove", (e)=>{
      if(!dragging || !S.selected || !S.drag) return;
      const p = toCanvas(e.clientX, e.clientY);
      Build.moveSelectedTo(S, p.x - S.drag.offX, p.y - S.drag.offY);
    });
    canvas.addEventListener("pointerup", ()=>{
      dragging=false; S.drag=null;
      Storage.save(S);
    });
  }

  function renderAll(S){
    updateTopBadges(S);
    updateServiceKPIs(S);
    renderReservations(S);
    renderInspector(S);
    renderStaff(S);
    if(S.hints.enabled && !S.hints.pinned) renderHintsBox(S);
    else renderHintsBox(S);
    Renderer.draw(ui.ctx, S);
  }

  return { ui, wire, renderAll };
});

// -------------------- main --------------------
RT.define("main", ["storage","state","staff","reservations","ui","tutorial","service"], (Storage, State, Staff, Res, UI, Tutorial, Service) => {
  let S = Storage.load() || State.createState();
  Staff.ensureDefaultCooks(S);

  // initial bookings
  if(!S.reservations || !S.reservations.length) Res.regenerate(S);

  UI.wire(S);

  // auto tutorial (small delay so layout is ready)
  setTimeout(()=>Tutorial.maybeAuto(), 450);

  let last = performance.now();
  function loop(now){
    const rawDt = Math.min(0.05, (now-last)/1000);
    last = now;
    const dt = rawDt * (S.paused ? 0 : S.speed);

    if(S.mode==="SERVICE" && S.running && !S.paused){
      RT.require("service").tick(S, dt, UI.ui.toast);
      try{ RT.require("actors").tick(S, dt); }catch(e){}
    }

    UI.renderAll(S);

    if(Math.random() < 0.05) Storage.save(S);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
});

// Boot
RT.require("main");
</script>
</body>
</html>
